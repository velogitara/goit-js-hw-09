{"version":3,"sources":["../node_modules/bootstrap.native/dist/bootstrap-native.esm.js","js/01-color-switcher.js"],"names":["EventRegistry","globalListener","e","that","type","forEach","elementsMap","element","listenersMap","listenerMap","listener","options","apply","once","removeListener","addListener","eventType","Map","oneEventMap","has","set","oneElementMap","get","size","addEventListener","savedOptions","eventOptions","undefined","delete","removeEventListener","EventListener","on","off","registry","mouseclickEvent","transitionEndEvent","transitionDelay","transitionProperty","getElementStyle","property","computedStyle","getComputedStyle","getElementTransitionDelay","propertyValue","delayValue","delayScale","includes","duration","parseFloat","Number","isNaN","transitionDuration","getElementTransitionDuration","durationValue","durationScale","emulateTransitionEnd","handler","called","endEvent","Event","delay","transitionEndWrapper","target","setTimeout","dispatchEvent","getDocument","node","HTMLElement","ownerDocument","Window","document","window","parentNodes","Document","Element","elementNodes","querySelector","selector","parent","lookUp","some","x","closest","getRootNode","host","ObjectAssign","obj","source","Object","assign","hasClass","classNAME","classList","contains","removeClass","remove","event","componentData","Data","component","instance","getAllFor","allForC","instanceMap","getInstance","OriginalEvent","EventType","config","OriginalCustomEvent","CustomEvent","cancelable","bubbles","fadeClass","showClass","dataBsDismiss","alertString","alertComponent","getAttribute","attribute","normalizeValue","value","ObjectKeys","keys","toLowerCase","normalizeOptions","defaultOps","inputOps","ns","data","dataset","normalOps","dataOps","k","key","replace","match","version","Version","BaseComponent","constructor","self","Error","name","prevInstance","dispose","defaults","length","prop","alertSelector","alertDismissSelector","getAlertInstance","alertInitCallback","Alert","closeAlertEvent","closedAlertEvent","alertTransitionEnd","toggleAlertHandler","add","action","dismiss","close","defaultPrevented","init","ariaPressed","setAttribute","addClass","activeClass","dataBsToggle","buttonString","buttonComponent","buttonSelector","getButtonInstance","buttonInitCallback","Button","toggleButtonHandler","toggle","isActive","preventDefault","mouseenterEvent","mouseleaveEvent","keydownEvent","touchmoveEvent","touchendEvent","touchstartEvent","keyArrowLeft","keyArrowRight","getWindow","defaultView","getBoundingClientRect","includeScale","width","height","top","right","bottom","left","scaleX","scaleY","offsetWidth","offsetHeight","Math","round","y","getDocumentElement","documentElement","isElementInScrollRange","clientHeight","isRTL","dir","querySelectorAll","getElementsByClassName","TimeCache","Timer","callback","keyTimers","clear","clearTimeout","reflow","passiveHandler","passive","dataBsTarget","carouselString","carouselComponent","dataBsParent","dataBsContainer","getTargetElement","targetAttr","doc","map","att","attValue","filter","carouselSelector","carouselItem","dataBsSlideTo","dataBsSlide","pausedClass","carouselDefaults","pause","keyboard","touch","interval","getCarouselInstance","carouselInitCallback","Carousel","startX","currentX","endX","carouselSlideEvent","carouselSlidEvent","carouselTransitionEndHandler","index","direction","slides","isAnimating","activeItem","getActiveIndex","orientation","directionClass","hidden","isPaused","cycle","carouselPauseHandler","carouselResumeHandler","carouselIndicatorHandler","newIndex","to","carouselControlsHandler","next","prev","carouselKeyHandler","code","RTL","arrowKeyNext","carouselTouchDownHandler","isTouch","changedTouches","pageX","toggleCarouselTouchHandlers","carouselTouchMoveHandler","carouselTouchEndHandler","relatedTarget","abs","activateCarouselIndicator","pageIndex","indicators","toggleCarouselHandlers","controls","arrow","indicator","indexOf","id","idx","eventProperties","from","itemClasses","slide","c","ariaExpanded","collapsingClass","collapseString","collapseComponent","collapseSelector","collapseToggleSelector","collapseDefaults","getCollapseInstance","collapseInitCallback","Collapse","showCollapseEvent","shownCollapseEvent","hideCollapseEvent","hiddenCollapseEvent","expandCollapse","triggers","style","scrollHeight","btn","collapseContent","toggleCollapseHandler","collapseClickHandler","trigger","tagName","hide","show","activeCollapse","activeCollapseInstance","find","i","focusEvent","keyupEvent","scrollEvent","resizeEvent","keyArrowUp","keyArrowDown","keyEscape","hasAttribute","setElementStyle","styles","focus","dropdownMenuClasses","dropdownComponent","dropdownMenuClass","isEmptyAnchor","parentAnchor","href","slice","dropdownString","dropupString","dropstartString","dropendString","dropdownSelector","getDropdownInstance","dropdownInitCallback","Dropdown","dropdownMenuEndClass","verticalClass","horizontalClass","menuFocusTags","dropdownDefaults","offset","display","showDropdownEvent","shownDropdownEvent","hideDropdownEvent","hiddenDropdownEvent","styleDropdown","menu","parentElement","menuEnd","p","positionClass","dropdownMargin","dropdown","dropup","dropstart","dropend","dropdownPosition","menuWidth","menuHeight","clientWidth","targetLeft","targetTop","targetWidth","targetHeight","leftFullExceed","rightFullExceed","bottomExceed","bottomFullExceed","topExceed","leftExceed","rightExceed","margin","join","getMenuItems","children","firstElementChild","toggleDropdownDismiss","open","dropdownDismissHandler","dropdownPreventScroll","dropdownKeyHandler","ev","dropdownLayoutHandler","toggleDropdownHandler","dropdownClickHandler","getCurrentOpenDropdown","currentParent","hasData","isForm","activeElement","menuItems","currentElement","currentInstance","ariaHidden","ariaModal","removeAttribute","getDocumentBody","body","modalString","modalComponent","isShadowRoot","ShadowRoot","getParentNode","nodeName","assignedSlot","parentNode","isTableElement","isHTMLElement","getElementContainer","getOffset","majorBlockTags","offsetParent","win","containers","shadowRoot","push","every","r","fixedTopClass","fixedBottomClass","stickyTopClass","positionStickyClass","getFixedItems","resetScrollbar","bd","paddingRight","overflow","fixedItems","fixed","marginRight","measureScrollbar","innerWidth","setScrollbar","bodyPad","parseInt","sbWidth","itemPadValue","itemMValue","createElement","param","attr","newElement","offcanvasString","backdropString","modalBackdropClass","offcanvasBackdropClass","modalActiveSelector","offcanvasActiveSelector","overlay","getCurrentOpen","toggleOverlayType","isModal","targetClass","appendOverlay","container","hasFade","append","showOverlay","hideOverlay","removeOverlay","isVisible","modalSelector","modalToggleSelector","modalDismissSelector","modalStaticClass","modalDefaults","backdrop","getModalInstance","modalInitCallback","Modal","showModalEvent","shownModalEvent","hideModalEvent","hiddenModalEvent","setModalScrollbar","scrollbarWidth","modalHeight","modalScrollHeight","modalOverflow","pad","toggleModalDismiss","modalDismissHandler","update","modalKeyHandler","toggleModalHandler","modalClickHandler","afterModalHide","focusElement","afterModalShow","beforeModalShow","beforeModalHide","force","isStatic","modalDialog","selectedText","getSelection","toString","targetInsideDialog","staticTransitionEnd","bind","overlayDelay","currentOpen","offcanvasComponent","offcanvasSelector","offcanvasToggleSelector","offcanvasDismissSelector","offcanvasTogglingClass","offcanvasDefaults","scroll","getOffcanvasInstance","offcanvasInitCallback","Offcanvas","showOffcanvasEvent","shownOffcanvasEvent","hideOffcanvasEvent","hiddenOffcanvasEvent","setOffCanvasScrollbar","toggleOffcanvasEvents","offcanvasTriggerHandler","toggleOffCanvasDismiss","offcanvasKeyDismissHandler","offcanvasDismissHandler","beforeOffcanvasShow","visibility","showOffcanvasComplete","beforeOffcanvasHide","blur","hideOffcanvasComplete","offCanvasDismiss","selection","visibleTrigger","popoverString","popoverComponent","tooltipString","getTipTemplate","tipType","isTooltip","isMedia","SVGElement","HTMLImageElement","HTMLVideoElement","mediaType","getNodeScroll","isWin","scrollX","scrollLeft","scrollY","scrollTop","isScaledElement","getRectRelativeToOffsetParent","isParentAnElement","rect","offsets","offsetRect","clientLeft","clientTop","tipClassPositions","styleTip","tipClasses","tooltip","tipPositions","isPopover","tipWidth","tipHeight","windowWidth","windowHeight","placement","parentLeft","parentRight","parentTop","parentWidth","parentPosition","fixedParent","staticParent","isSticky","leftBoundry","rightBoundry","elemWidth","elemHeight","elemRectLeft","elemRectRight","elemRectTop","topPosition","leftPosition","rightPosition","arrowTop","arrowLeft","arrowRight","arrowWidth","arrowHeight","arrowAdjust","horizontal","vertical","className","eX","eY","pageY","clientX","clientY","tooltipDefaults","template","title","customClass","sanitizeFn","animation","ariaDescribedBy","mousedownEvent","mousemoveEvent","focusinEvent","focusoutEvent","mousehoverEvent","elementUID","elementMapUID","elementIDMap","getUID","result","elID","elMap","elkey","userAgentData","uaDATA","navigator","userAgent","userAgentString","appleBrands","isApple","brands","test","brand","dataOriginalTitle","tooltipComponent","setHtml","content","dirty","trim","tempDocument","DOMParser","parseFromString","method","createTip","dismissible","tipString","btnClose","placementClass","popoverTemplate","htmlMarkup","cloneNode","bodyClass","tooltipHeader","tooltipBody","isVisibleTip","tip","tooltipSelector","titleAttr","getTooltipInstance","tooltipInitCallback","Tooltip","removeTooltip","disposeTooltipComplete","toggleTooltipHandlers","toggleTooltipTitle","toggleTooltipAction","handleTouch","tooltipShownAction","shownTooltipEvent","tooltipHiddenAction","hiddenTooltipEvent","enabled","triggerOptions","split","elemIsMedia","tr","toggleTooltipOpenHandlers","parentModal","parentOffcanvas","scrollTarget","titleAtt","tipComponent","elem","idealContainer","outTimer","showTooltipEvent","hideTooltipEvent","enable","disable","toggleEnabled","popoverSelector","popoverDefaults","Popover","getPopoverInstance","popoverInitCallback","getElementsByTagName","scrollspyString","scrollspyComponent","scrollspySelector","scrollspyDefaults","getScrollSpyInstance","scrollspyInitCallback","ScrollSpy","activateScrollSpy","updateSpyTargets","itemsLength","links","scrollHEIGHT","getScrollHeight","targetItem","items","maxScroll","getOffsetHeight","link","charAt","offsetTop","innerHeight","item","activate","parents","parentItem","menuItem","parentLink","previousElementSibling","toggleSpyHandlers","refresh","newActiveItem","ariaSelected","tabString","tabComponent","tabSelector","getTabInstance","tabInitCallback","Tab","showTabEvent","shownTabEvent","hideTabEvent","hiddenTabEvent","tabPrivate","triggerTabEnd","tabContent","nav","triggerTabShow","nextContent","tab","currentHeight","nextHeight","triggerTabHide","getActiveTab","activeTabs","getParentDropdown","toggleTabHandler","tabClickHandler","firstTab","firstTabContent","activeDropdown","toastString","toastComponent","toastSelector","toastDismissSelector","showingClass","hideClass","toastDefaults","autohide","getToastInstance","toastInitCallback","Toast","showToastEvent","shownToastEvent","hideToastEvent","hiddenToastEvent","showToastComplete","hideToastComplete","hideToast","showToast","toggleToastHandlers","interactiveToastHandler","completeDisposeToast","matches","componentsList","initComponentDataAPI","collection","removeComponentDataAPI","context","compData","initCallback","elemCollection","comp","removeDataAPI","BSN","modal","console","log","refs","startBtn","stopBtn","getRandomHexColor","floor","random"],"mappings":"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","file":"01-color-switcher.2c20a34e.js","sourceRoot":"../src","sourcesContent":["/*!\n  * Native JavaScript for Bootstrap v4.1.2 (https://thednp.github.io/bootstrap.native/)\n  * Copyright 2015-2022 © dnp_theme\n  * Licensed under MIT (https://github.com/thednp/bootstrap.native/blob/master/LICENSE)\n  */\n/** @type {Record<string, any>} */\nconst EventRegistry = {};\n\n/**\n * The global event listener.\n *\n * @this {Element | HTMLElement | Window | Document}\n * @param {Event} e\n * @returns {void}\n */\nfunction globalListener(e) {\n  const that = this;\n  const { type } = e;\n  const oneEvMap = EventRegistry[type] ? [...EventRegistry[type]] : [];\n\n  oneEvMap.forEach((elementsMap) => {\n    const [element, listenersMap] = elementsMap;\n    [...listenersMap].forEach((listenerMap) => {\n      if (element === that) {\n        const [listener, options] = listenerMap;\n        listener.apply(element, [e]);\n\n        if (options && options.once) {\n          removeListener(element, type, listener, options);\n        }\n      }\n    });\n  });\n}\n\n/**\n * Register a new listener with its options and attach the `globalListener`\n * to the target if this is the first listener.\n *\n * @param {Element | HTMLElement | Window | Document} element\n * @param {string} eventType\n * @param {EventListenerObject['handleEvent']} listener\n * @param {AddEventListenerOptions=} options\n */\nconst addListener = (element, eventType, listener, options) => {\n  // get element listeners first\n  if (!EventRegistry[eventType]) {\n    EventRegistry[eventType] = new Map();\n  }\n  const oneEventMap = EventRegistry[eventType];\n\n  if (!oneEventMap.has(element)) {\n    oneEventMap.set(element, new Map());\n  }\n  const oneElementMap = oneEventMap.get(element);\n\n  // get listeners size\n  const { size } = oneElementMap;\n\n  // register listener with its options\n  if (oneElementMap) {\n    oneElementMap.set(listener, options);\n  }\n\n  // add listener last\n  if (!size) {\n    element.addEventListener(eventType, globalListener, options);\n  }\n};\n\n/**\n * Remove a listener from registry and detach the `globalListener`\n * if no listeners are found in the registry.\n *\n * @param {Element | HTMLElement | Window | Document} element\n * @param {string} eventType\n * @param {EventListenerObject['handleEvent']} listener\n * @param {AddEventListenerOptions=} options\n */\nconst removeListener = (element, eventType, listener, options) => {\n  // get listener first\n  const oneEventMap = EventRegistry[eventType];\n  const oneElementMap = oneEventMap && oneEventMap.get(element);\n  const savedOptions = oneElementMap && oneElementMap.get(listener);\n\n  // also recover initial options\n  const { options: eventOptions } = savedOptions !== undefined\n    ? savedOptions\n    : { options };\n\n  // unsubscribe second, remove from registry\n  if (oneElementMap && oneElementMap.has(listener)) oneElementMap.delete(listener);\n  if (oneEventMap && (!oneElementMap || !oneElementMap.size)) oneEventMap.delete(element);\n  if (!oneEventMap || !oneEventMap.size) delete EventRegistry[eventType];\n\n  // remove listener last\n  if (!oneElementMap || !oneElementMap.size) {\n    element.removeEventListener(eventType, globalListener, eventOptions);\n  }\n};\n\n/**\n * Advanced event listener based on subscribe / publish pattern.\n * @see https://www.patterns.dev/posts/classic-design-patterns/#observerpatternjavascript\n * @see https://gist.github.com/shystruk/d16c0ee7ac7d194da9644e5d740c8338#file-subpub-js\n * @see https://hackernoon.com/do-you-still-register-window-event-listeners-in-each-component-react-in-example-31a4b1f6f1c8\n */\nconst EventListener = {\n  on: addListener,\n  off: removeListener,\n  globalListener,\n  registry: EventRegistry,\n};\n\n/**\n * A global namespace for `click` event.\n * @type {string}\n */\nconst mouseclickEvent = 'click';\n\n/**\n * A global namespace for 'transitionend' string.\n * @type {string}\n */\nconst transitionEndEvent = 'transitionend';\n\n/**\n * A global namespace for 'transitionDelay' string.\n * @type {string}\n */\nconst transitionDelay = 'transitionDelay';\n\n/**\n * A global namespace for `transitionProperty` string for modern browsers.\n *\n * @type {string}\n */\nconst transitionProperty = 'transitionProperty';\n\n/**\n * Shortcut for `window.getComputedStyle(element).propertyName`\n * static method.\n *\n * * If `element` parameter is not an `HTMLElement`, `getComputedStyle`\n * throws a `ReferenceError`.\n *\n * @param {HTMLElement | Element} element target\n * @param {string} property the css property\n * @return {string} the css property value\n */\nfunction getElementStyle(element, property) {\n  const computedStyle = getComputedStyle(element);\n\n  // @ts-ignore -- must use camelcase strings,\n  // or non-camelcase strings with `getPropertyValue`\n  return property in computedStyle ? computedStyle[property] : '';\n}\n\n/**\n * Utility to get the computed `transitionDelay`\n * from Element in miliseconds.\n *\n * @param {HTMLElement | Element} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDelay(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const delayValue = getElementStyle(element, transitionDelay);\n\n  const delayScale = delayValue.includes('ms') ? 1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(delayValue) * delayScale : 0;\n\n  return !Number.isNaN(duration) ? duration : 0;\n}\n\n/**\n * A global namespace for 'transitionDuration' string.\n * @type {string}\n */\nconst transitionDuration = 'transitionDuration';\n\n/**\n * Utility to get the computed `transitionDuration`\n * from Element in miliseconds.\n *\n * @param {HTMLElement | Element} element target\n * @return {number} the value in miliseconds\n */\nfunction getElementTransitionDuration(element) {\n  const propertyValue = getElementStyle(element, transitionProperty);\n  const durationValue = getElementStyle(element, transitionDuration);\n  const durationScale = durationValue.includes('ms') ? 1 : 1000;\n  const duration = propertyValue && propertyValue !== 'none'\n    ? parseFloat(durationValue) * durationScale : 0;\n\n  return !Number.isNaN(duration) ? duration : 0;\n}\n\n/**\n * Utility to make sure callbacks are consistently\n * called when transition ends.\n *\n * @param {HTMLElement | Element} element target\n * @param {EventListener} handler `transitionend` callback\n */\nfunction emulateTransitionEnd(element, handler) {\n  let called = 0;\n  const endEvent = new Event(transitionEndEvent);\n  const duration = getElementTransitionDuration(element);\n  const delay = getElementTransitionDelay(element);\n\n  if (duration) {\n    /**\n     * Wrap the handler in on -> off callback\n     * @type {EventListener} e Event object\n     */\n    const transitionEndWrapper = (e) => {\n      if (e.target === element) {\n        handler.apply(element, [e]);\n        element.removeEventListener(transitionEndEvent, transitionEndWrapper);\n        called = 1;\n      }\n    };\n    element.addEventListener(transitionEndEvent, transitionEndWrapper);\n    setTimeout(() => {\n      if (!called) element.dispatchEvent(endEvent);\n    }, duration + delay + 17);\n  } else {\n    handler.apply(element, [endEvent]);\n  }\n}\n\n/**\n * Returns the `document` or the `#document` element.\n * @see https://github.com/floating-ui/floating-ui\n * @param {(Node | HTMLElement | Element | globalThis)=} node\n * @returns {Document}\n */\nfunction getDocument(node) {\n  if (node instanceof HTMLElement) return node.ownerDocument;\n  if (node instanceof Window) return node.document;\n  return window.document;\n}\n\n/**\n * A global array of possible `ParentNode`.\n */\nconst parentNodes = [Document, Element, HTMLElement];\n\n/**\n * A global array with `Element` | `HTMLElement`.\n */\nconst elementNodes = [Element, HTMLElement];\n\n/**\n * Utility to check if target is typeof `HTMLElement`, `Element`, `Node`\n * or find one that matches a selector.\n *\n * @param {HTMLElement | Element | string} selector the input selector or target element\n * @param {(HTMLElement | Element | Document)=} parent optional node to look into\n * @return {(HTMLElement | Element)?} the `HTMLElement` or `querySelector` result\n */\nfunction querySelector(selector, parent) {\n  const lookUp = parentNodes.some((x) => parent instanceof x)\n    ? parent : getDocument();\n\n  // @ts-ignore\n  return elementNodes.some((x) => selector instanceof x)\n    // @ts-ignore\n    ? selector : lookUp.querySelector(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.closest` method which also works\n * with children of `ShadowRoot`. The order of the parameters\n * is intentional since they're both required.\n *\n * @see https://stackoverflow.com/q/54520554/803358\n *\n * @param {HTMLElement | Element} element Element to look into\n * @param {string} selector the selector name\n * @return {(HTMLElement | Element)?} the query result\n */\nfunction closest(element, selector) {\n  return element ? (element.closest(selector)\n    // @ts-ignore -- break out of `ShadowRoot`\n    || closest(element.getRootNode().host, selector)) : null;\n}\n\n/**\n * Shortcut for `Object.assign()` static method.\n * @param  {Record<string, any>} obj a target object\n * @param  {Record<string, any>} source a source object\n */\nconst ObjectAssign = (obj, source) => Object.assign(obj, source);\n\n/**\n * Check class in `HTMLElement.classList`.\n *\n * @param {HTMLElement | Element} element target\n * @param {string} classNAME to check\n * @returns {boolean}\n */\nfunction hasClass(element, classNAME) {\n  return element.classList.contains(classNAME);\n}\n\n/**\n * Remove class from `HTMLElement.classList`.\n *\n * @param {HTMLElement | Element} element target\n * @param {string} classNAME to remove\n * @returns {void}\n */\nfunction removeClass(element, classNAME) {\n  element.classList.remove(classNAME);\n}\n\n/**\n * Shortcut for the `Element.dispatchEvent(Event)` method.\n *\n * @param {HTMLElement | Element} element is the target\n * @param {Event} event is the `Event` object\n */\nconst dispatchEvent = (element, event) => element.dispatchEvent(event);\n\n/** @type {Map<string, Map<HTMLElement | Element, Record<string, any>>>} */\nconst componentData = new Map();\n/**\n * An interface for web components background data.\n * @see https://github.com/thednp/bootstrap.native/blob/master/src/components/base-component.js\n */\nconst Data = {\n  /**\n   * Sets web components data.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {string} component the component's name or a unique key\n   * @param {Record<string, any>} instance the component instance\n   */\n  set: (target, component, instance) => {\n    const element = querySelector(target);\n    if (!element) return;\n\n    if (!componentData.has(component)) {\n      componentData.set(component, new Map());\n    }\n\n    const instanceMap = componentData.get(component);\n    // @ts-ignore - not undefined, but defined right above\n    instanceMap.set(element, instance);\n  },\n\n  /**\n   * Returns all instances for specified component.\n   * @param {string} component the component's name or a unique key\n   * @returns {Map<HTMLElement | Element, Record<string, any>>?} all the component instances\n   */\n  getAllFor: (component) => {\n    const instanceMap = componentData.get(component);\n\n    return instanceMap || null;\n  },\n\n  /**\n   * Returns the instance associated with the target.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {string} component the component's name or a unique key\n   * @returns {Record<string, any>?} the instance\n   */\n  get: (target, component) => {\n    const element = querySelector(target);\n    const allForC = Data.getAllFor(component);\n    const instance = element && allForC && allForC.get(element);\n\n    return instance || null;\n  },\n\n  /**\n   * Removes web components data.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {string} component the component's name or a unique key\n   */\n  remove: (target, component) => {\n    const element = querySelector(target);\n    const instanceMap = componentData.get(component);\n    if (!instanceMap || !element) return;\n\n    instanceMap.delete(element);\n\n    if (instanceMap.size === 0) {\n      componentData.delete(component);\n    }\n  },\n};\n\n/**\n * An alias for `Data.get()`.\n * @type {SHORTER.getInstance<any>}\n */\nconst getInstance = (target, component) => Data.get(target, component);\n\n/**\n * Returns a namespaced `CustomEvent` specific to each component.\n * @param {string} EventType Event.type\n * @param {Record<string, any>=} config Event.options | Event.properties\n * @returns {SHORTER.OriginalEvent} a new namespaced event\n */\nfunction OriginalEvent(EventType, config) {\n  const OriginalCustomEvent = new CustomEvent(EventType, {\n    cancelable: true, bubbles: true,\n  });\n\n  if (config instanceof Object) {\n    ObjectAssign(OriginalCustomEvent, config);\n  }\n  return OriginalCustomEvent;\n}\n\n/**\n * Global namespace for most components `fade` class.\n */\nconst fadeClass = 'fade';\n\n/**\n * Global namespace for most components `show` class.\n */\nconst showClass = 'show';\n\n/**\n * Global namespace for most components `dismiss` option.\n */\nconst dataBsDismiss = 'data-bs-dismiss';\n\n/** @type {string} */\nconst alertString = 'alert';\n\n/** @type {string} */\nconst alertComponent = 'Alert';\n\n/**\n * Shortcut for `HTMLElement.getAttribute()` method.\n * @param {HTMLElement | Element} element target element\n * @param {string} attribute attribute name\n * @returns {string?} attribute value\n */\nconst getAttribute = (element, attribute) => element.getAttribute(attribute);\n\n/**\n * The raw value or a given component option.\n *\n * @typedef {string | HTMLElement | Function | number | boolean | null} niceValue\n */\n\n/**\n * Utility to normalize component options\n *\n * @param {any} value the input value\n * @return {niceValue} the normalized value\n */\nfunction normalizeValue(value) {\n  if (value === 'true') { // boolean\n    return true;\n  }\n\n  if (value === 'false') { // boolean\n    return false;\n  }\n\n  if (!Number.isNaN(+value)) { // number\n    return +value;\n  }\n\n  if (value === '' || value === 'null') { // null\n    return null;\n  }\n\n  // string / function / HTMLElement / object\n  return value;\n}\n\n/**\n * Shortcut for `Object.keys()` static method.\n * @param  {Record<string, any>} obj a target object\n * @returns {string[]}\n */\nconst ObjectKeys = (obj) => Object.keys(obj);\n\n/**\n * Shortcut for `String.toLowerCase()`.\n *\n * @param {string} source input string\n * @returns {string} lowercase output string\n */\nconst toLowerCase = (source) => source.toLowerCase();\n\n/**\n * Utility to normalize component options.\n *\n * @param {HTMLElement | Element} element target\n * @param {Record<string, any>} defaultOps component default options\n * @param {Record<string, any>} inputOps component instance options\n * @param {string=} ns component namespace\n * @return {Record<string, any>} normalized component options object\n */\nfunction normalizeOptions(element, defaultOps, inputOps, ns) {\n  // @ts-ignore -- our targets are always `HTMLElement`\n  const data = { ...element.dataset };\n  /** @type {Record<string, any>} */\n  const normalOps = {};\n  /** @type {Record<string, any>} */\n  const dataOps = {};\n  const title = 'title';\n\n  ObjectKeys(data).forEach((k) => {\n    const key = ns && k.includes(ns)\n      ? k.replace(ns, '').replace(/[A-Z]/, (match) => toLowerCase(match))\n      : k;\n\n    dataOps[key] = normalizeValue(data[k]);\n  });\n\n  ObjectKeys(inputOps).forEach((k) => {\n    inputOps[k] = normalizeValue(inputOps[k]);\n  });\n\n  ObjectKeys(defaultOps).forEach((k) => {\n    if (k in inputOps) {\n      normalOps[k] = inputOps[k];\n    } else if (k in dataOps) {\n      normalOps[k] = dataOps[k];\n    } else {\n      normalOps[k] = k === title\n        ? getAttribute(element, title)\n        : defaultOps[k];\n    }\n  });\n\n  return normalOps;\n}\n\nvar version = \"4.1.2\";\n\nconst Version = version;\n\n/* Native JavaScript for Bootstrap 5 | Base Component\n----------------------------------------------------- */\n\n/** Returns a new `BaseComponent` instance. */\nclass BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target `Element` or selector string\n   * @param {BSN.ComponentOptions=} config component instance options\n   */\n  constructor(target, config) {\n    const self = this;\n    const element = querySelector(target);\n\n    if (!element) {\n      throw Error(`${self.name} Error: \"${target}\" is not a valid selector.`);\n    }\n\n    /** @static @type {BSN.ComponentOptions} */\n    self.options = {};\n\n    const prevInstance = Data.get(element, self.name);\n    if (prevInstance) prevInstance.dispose();\n\n    /** @type {HTMLElement | Element} */\n    self.element = element;\n\n    if (self.defaults && Object.keys(self.defaults).length) {\n      self.options = normalizeOptions(element, self.defaults, (config || {}), 'bs');\n    }\n\n    Data.set(element, self.name, self);\n  }\n\n  /* eslint-disable */\n  /** @static */\n  get version() { return Version; }\n  /* eslint-enable */\n\n  /** @static */\n  get name() { return this.constructor.name; }\n\n  /** @static */\n  // @ts-ignore\n  get defaults() { return this.constructor.defaults; }\n\n  /**\n   * Removes component from target element;\n   */\n  dispose() {\n    const self = this;\n    Data.remove(self.element, self.name);\n    // @ts-ignore\n    ObjectKeys(self).forEach((prop) => { self[prop] = null; });\n  }\n}\n\n/* Native JavaScript for Bootstrap 5 | Alert\n-------------------------------------------- */\n\n// ALERT PRIVATE GC\n// ================\nconst alertSelector = `.${alertString}`;\nconst alertDismissSelector = `[${dataBsDismiss}=\"${alertString}\"]`;\n\n/**\n * Static method which returns an existing `Alert` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Alert>}\n */\nconst getAlertInstance = (element) => getInstance(element, alertComponent);\n\n/**\n* An `Alert` initialization callback.\n* @type {BSN.InitCallback<Alert>}\n*/\nconst alertInitCallback = (element) => new Alert(element);\n\n// ALERT CUSTOM EVENTS\n// ===================\nconst closeAlertEvent = OriginalEvent(`close.bs.${alertString}`);\nconst closedAlertEvent = OriginalEvent(`closed.bs.${alertString}`);\n\n// ALERT EVENT HANDLER\n// ===================\n/**\n * Alert `transitionend` callback.\n * @param {Alert} self target Alert instance\n */\nfunction alertTransitionEnd(self) {\n  const { element } = self;\n  toggleAlertHandler(self);\n\n  dispatchEvent(element, closedAlertEvent);\n\n  self.dispose();\n  element.remove();\n}\n\n// ALERT PRIVATE METHOD\n// ====================\n/**\n * Toggle on / off the `click` event listener.\n * @param {Alert} self the target alert instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleAlertHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { dismiss } = self;\n  if (dismiss) action(dismiss, mouseclickEvent, self.close);\n}\n\n// ALERT DEFINITION\n// ================\n/** Creates a new Alert instance. */\nclass Alert extends BaseComponent {\n  /** @param {HTMLElement | Element | string} target element or selector */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // the dismiss button\n    /** @static @type {(HTMLElement | Element)?} */\n    self.dismiss = querySelector(alertDismissSelector, element);\n\n    // add event listener\n    toggleAlertHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return alertComponent; }\n  /* eslint-enable */\n\n  // ALERT PUBLIC METHODS\n  // ====================\n  /**\n   * Public method that hides the `.alert` element from the user,\n   * disposes the instance once animation is complete, then\n   * removes the element from the DOM.\n   *\n   * @param {Event=} e most likely the `click` event\n   * @this {Alert} the `Alert` instance or `EventTarget`\n   */\n  close(e) {\n    // @ts-ignore\n    const self = e ? getAlertInstance(closest(this, alertSelector)) : this;\n    if (!self) return;\n    const { element } = self;\n\n    if (hasClass(element, showClass)) {\n      dispatchEvent(element, closeAlertEvent);\n      if (closeAlertEvent.defaultPrevented) return;\n\n      removeClass(element, showClass);\n\n      if (hasClass(element, fadeClass)) {\n        emulateTransitionEnd(element, () => alertTransitionEnd(self));\n      } else alertTransitionEnd(self);\n    }\n  }\n\n  /** Remove the component from target element. */\n  dispose() {\n    toggleAlertHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Alert, {\n  selector: alertSelector,\n  init: alertInitCallback,\n  getInstance: getAlertInstance,\n});\n\n/**\n * A global namespace for aria-pressed.\n * @type {string}\n */\nconst ariaPressed = 'aria-pressed';\n\n/**\n * Shortcut for `HTMLElement.setAttribute()` method.\n * @param  {HTMLElement | Element} element target element\n * @param  {string} attribute attribute name\n * @param  {string} value attribute value\n * @returns {void}\n */\nconst setAttribute = (element, attribute, value) => element.setAttribute(attribute, value);\n\n/**\n * Add class to `HTMLElement.classList`.\n *\n * @param {HTMLElement | Element} element target\n * @param {string} classNAME to add\n * @returns {void}\n */\nfunction addClass(element, classNAME) {\n  element.classList.add(classNAME);\n}\n\n/**\n * Global namespace for most components active class.\n */\nconst activeClass = 'active';\n\n/**\n * Global namespace for most components `toggle` option.\n */\nconst dataBsToggle = 'data-bs-toggle';\n\n/** @type {string} */\nconst buttonString = 'button';\n\n/** @type {string} */\nconst buttonComponent = 'Button';\n\n/* Native JavaScript for Bootstrap 5 | Button\n---------------------------------------------*/\n\n// BUTTON PRIVATE GC\n// =================\nconst buttonSelector = `[${dataBsToggle}=\"${buttonString}\"]`;\n\n/**\n * Static method which returns an existing `Button` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Button>}\n */\nconst getButtonInstance = (element) => getInstance(element, buttonComponent);\n\n/**\n * A `Button` initialization callback.\n * @type {BSN.InitCallback<Button>}\n */\nconst buttonInitCallback = (element) => new Button(element);\n\n// BUTTON PRIVATE METHOD\n// =====================\n/**\n * Toggles on/off the `click` event listener.\n * @param {Button} self the `Button` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleButtonHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, self.toggle);\n}\n\n// BUTTON DEFINITION\n// =================\n/** Creates a new `Button` instance. */\nclass Button extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target usually a `.btn` element\n   */\n  constructor(target) {\n    super(target);\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n\n    // set initial state\n    /** @type {boolean} */\n    self.isActive = hasClass(element, activeClass);\n    setAttribute(element, ariaPressed, `${!!self.isActive}`);\n\n    // add event listener\n    toggleButtonHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return buttonComponent; }\n  /* eslint-enable */\n\n  // BUTTON PUBLIC METHODS\n  // =====================\n  /**\n   * Toggles the state of the target button.\n   * @param {MouseEvent} e usually `click` Event object\n   */\n  toggle(e) {\n    if (e) e.preventDefault();\n    // @ts-ignore\n    const self = e ? getButtonInstance(this) : this;\n    if (!self) return;\n    const { element } = self;\n\n    if (hasClass(element, 'disabled')) return;\n    self.isActive = hasClass(element, activeClass);\n    const { isActive } = self;\n\n    const action = isActive ? removeClass : addClass;\n\n    action(element, activeClass);\n    setAttribute(element, ariaPressed, isActive ? 'false' : 'true');\n  }\n\n  /** Removes the `Button` component from the target element. */\n  dispose() {\n    toggleButtonHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Button, {\n  selector: buttonSelector,\n  init: buttonInitCallback,\n  getInstance: getButtonInstance,\n});\n\n/**\n * A global namespace for `mouseenter` event.\n * @type {string}\n */\nconst mouseenterEvent = 'mouseenter';\n\n/**\n * A global namespace for `mouseleave` event.\n * @type {string}\n */\nconst mouseleaveEvent = 'mouseleave';\n\n/**\n * A global namespace for `keydown` event.\n * @type {string}\n */\nconst keydownEvent = 'keydown';\n\n/**\n * A global namespace for `touchmove` event.\n * @type {string}\n */\nconst touchmoveEvent = 'touchmove';\n\n/**\n * A global namespace for `touchend` event.\n * @type {string}\n */\nconst touchendEvent = 'touchend';\n\n/**\n * A global namespace for `touchstart` event.\n * @type {string}\n */\nconst touchstartEvent = 'touchstart';\n\n/**\n * A global namespace for `ArrowLeft` key.\n * @type {string} e.which = 37 equivalent\n */\nconst keyArrowLeft = 'ArrowLeft';\n\n/**\n * A global namespace for `ArrowRight` key.\n * @type {string} e.which = 39 equivalent\n */\nconst keyArrowRight = 'ArrowRight';\n\n/**\n * Returns the `Window` object of a target node.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {(Node | HTMLElement | Element | Window)=} node target node\n * @returns {globalThis}\n */\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!(node instanceof Window)) {\n    const { ownerDocument } = node;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  // @ts-ignore\n  return node;\n}\n\n/**\n * Returns the bounding client rect of a target `HTMLElement`.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Element} element event.target\n * @param {boolean=} includeScale when *true*, the target scale is also computed\n * @returns {SHORTER.BoundingClientRect} the bounding client rect object\n */\nfunction getBoundingClientRect(element, includeScale) {\n  const {\n    width, height, top, right, bottom, left,\n  } = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && element instanceof HTMLElement) {\n    const { offsetWidth, offsetHeight } = element;\n    scaleX = offsetWidth > 0 ? Math.round(width) / offsetWidth || 1 : 1;\n    scaleY = offsetHeight > 0 ? Math.round(height) / offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: width / scaleX,\n    height: height / scaleY,\n    top: top / scaleY,\n    right: right / scaleX,\n    bottom: bottom / scaleY,\n    left: left / scaleX,\n    x: left / scaleX,\n    y: top / scaleY,\n  };\n}\n\n/**\n * Returns the `document.documentElement` or the `<html>` element.\n *\n * @param {(Node | HTMLElement | Element | globalThis)=} node\n * @returns {HTMLElement | HTMLHtmlElement}\n */\nfunction getDocumentElement(node) {\n  return getDocument(node).documentElement;\n}\n\n/**\n * Utility to determine if an `HTMLElement`\n * is partially visible in viewport.\n *\n * @param {HTMLElement | Element} element target\n * @return {boolean} the query result\n */\nconst isElementInScrollRange = (element) => {\n  const { top, bottom } = getBoundingClientRect(element);\n  const { clientHeight } = getDocumentElement(element);\n  // checks bottom && top\n  return top <= clientHeight && bottom >= 0;\n};\n\n/**\n * Checks if a page is Right To Left.\n * @param {(HTMLElement | Element)=} node the target\n * @returns {boolean} the query result\n */\nconst isRTL = (node) => getDocumentElement(node).dir === 'rtl';\n\n/**\n * A shortcut for `(document|Element).querySelectorAll`.\n *\n * @param {string} selector the input selector\n * @param {(HTMLElement | Element | Document | Node)=} parent optional node to look into\n * @return {NodeListOf<HTMLElement | Element>} the query result\n */\nfunction querySelectorAll(selector, parent) {\n  const lookUp = parent && parentNodes\n    .some((x) => parent instanceof x) ? parent : getDocument();\n  // @ts-ignore -- `ShadowRoot` is also a node\n  return lookUp.querySelectorAll(selector);\n}\n\n/**\n * Shortcut for `HTMLElement.getElementsByClassName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByClassName`.\n *\n * @param {string} selector the class name\n * @param {(HTMLElement | Element | Document)=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement | Element>} the 'HTMLCollection'\n */\nfunction getElementsByClassName(selector, parent) {\n  const lookUp = parent && parentNodes.some((x) => parent instanceof x)\n    ? parent : getDocument();\n  return lookUp.getElementsByClassName(selector);\n}\n\n/** @type {Map<HTMLElement | Element, any>} */\nconst TimeCache = new Map();\n/**\n * An interface for one or more `TimerHandler`s per `Element`.\n * @see https://github.com/thednp/navbar.js/\n */\nconst Timer = {\n  /**\n   * Sets a new timeout timer for an element, or element -> key association.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {ReturnType<TimerHandler>} callback the callback\n   * @param {number} delay the execution delay\n   * @param {string=} key a unique key\n   */\n  set: (target, callback, delay, key) => {\n    const element = querySelector(target);\n\n    if (!element) return;\n\n    if (key && key.length) {\n      if (!TimeCache.has(element)) {\n        TimeCache.set(element, new Map());\n      }\n      const keyTimers = TimeCache.get(element);\n      keyTimers.set(key, setTimeout(callback, delay));\n    } else {\n      TimeCache.set(element, setTimeout(callback, delay));\n    }\n  },\n\n  /**\n   * Returns the timer associated with the target.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {string=} key a unique\n   * @returns {number?} the timer\n   */\n  get: (target, key) => {\n    const element = querySelector(target);\n\n    if (!element) return null;\n    const keyTimers = TimeCache.get(element);\n\n    if (key && key.length && keyTimers && keyTimers.get) {\n      return keyTimers.get(key) || null;\n    }\n    return keyTimers || null;\n  },\n\n  /**\n   * Clears the element's timer.\n   * @param {HTMLElement | Element | string} target target element\n   * @param {string=} key a unique key\n   */\n  clear: (target, key) => {\n    const element = querySelector(target);\n\n    if (!element) return;\n\n    if (key && key.length) {\n      const keyTimers = TimeCache.get(element);\n\n      if (keyTimers && keyTimers.get) {\n        clearTimeout(keyTimers.get(key));\n        keyTimers.delete(key);\n        if (keyTimers.size === 0) {\n          TimeCache.delete(element);\n        }\n      }\n    } else {\n      clearTimeout(TimeCache.get(element));\n      TimeCache.delete(element);\n    }\n  },\n};\n\n/**\n * Utility to force re-paint of an `HTMLElement` target.\n *\n * @param {HTMLElement | Element} element is the target\n * @return {number} the `Element.offsetHeight` value\n */\n// @ts-ignore\nconst reflow = (element) => element.offsetHeight;\n\n/**\n * A global namespace for most scroll event listeners.\n * @type {Partial<AddEventListenerOptions>}\n */\nconst passiveHandler = { passive: true };\n\n/**\n * Global namespace for most components `target` option.\n */\nconst dataBsTarget = 'data-bs-target';\n\n/** @type {string} */\nconst carouselString = 'carousel';\n\n/** @type {string} */\nconst carouselComponent = 'Carousel';\n\n/**\n * Global namespace for most components `parent` option.\n */\nconst dataBsParent = 'data-bs-parent';\n\n/**\n * Global namespace for most components `container` option.\n */\nconst dataBsContainer = 'data-bs-container';\n\n/**\n * Returns the `Element` that THIS one targets\n * via `data-bs-target`, `href`, `data-bs-parent` or `data-bs-container`.\n *\n * @param {HTMLElement | Element} element the target element\n * @returns {(HTMLElement | Element)?} the query result\n */\nfunction getTargetElement(element) {\n  const targetAttr = [dataBsTarget, dataBsParent, dataBsContainer, 'href'];\n  const doc = getDocument(element);\n\n  return targetAttr.map((att) => {\n    const attValue = getAttribute(element, att);\n    if (attValue) {\n      return att === dataBsParent ? closest(element, attValue) : querySelector(attValue, doc);\n    }\n    return null;\n  }).filter((x) => x)[0];\n}\n\n/* Native JavaScript for Bootstrap 5 | Carousel\n----------------------------------------------- */\n\n// CAROUSEL PRIVATE GC\n// ===================\nconst carouselSelector = `[data-bs-ride=\"${carouselString}\"]`;\nconst carouselItem = `${carouselString}-item`;\nconst dataBsSlideTo = 'data-bs-slide-to';\nconst dataBsSlide = 'data-bs-slide';\nconst pausedClass = 'paused';\n\nconst carouselDefaults = {\n  pause: 'hover',\n  keyboard: false,\n  touch: true,\n  interval: 5000,\n};\n\n/**\n * Static method which returns an existing `Carousel` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Carousel>}\n */\nconst getCarouselInstance = (element) => getInstance(element, carouselComponent);\n\n/**\n * A `Carousel` initialization callback.\n * @type {BSN.InitCallback<Carousel>}\n */\nconst carouselInitCallback = (element) => new Carousel(element);\n\nlet startX = 0;\nlet currentX = 0;\nlet endX = 0;\n\n// CAROUSEL CUSTOM EVENTS\n// ======================\nconst carouselSlideEvent = OriginalEvent(`slide.bs.${carouselString}`);\nconst carouselSlidEvent = OriginalEvent(`slid.bs.${carouselString}`);\n\n// CAROUSEL EVENT HANDLERS\n// =======================\n/**\n * The `transitionend` event listener of the `Carousel`.\n * @param {Carousel} self the `Carousel` instance\n */\nfunction carouselTransitionEndHandler(self) {\n  const {\n    index, direction, element, slides, options,\n  } = self;\n\n  // discontinue disposed instances\n  if (self.isAnimating && getCarouselInstance(element)) {\n    const activeItem = getActiveIndex(self);\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    addClass(slides[index], activeClass);\n    removeClass(slides[index], `${carouselItem}-${orientation}`);\n    removeClass(slides[index], `${carouselItem}-${directionClass}`);\n\n    removeClass(slides[activeItem], activeClass);\n    removeClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n    dispatchEvent(element, carouselSlidEvent);\n    Timer.clear(element, dataBsSlide);\n\n    // check for element, might have been disposed\n    if (!getDocument(element).hidden && options.interval\n      && !self.isPaused) {\n      self.cycle();\n    }\n  }\n}\n\n/**\n * Handles the `mouseenter` / `touchstart` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement | Element}\n */\nfunction carouselPauseHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n\n  if (self && !self.isPaused && !Timer.get(element, pausedClass)) {\n    addClass(element, pausedClass);\n  }\n}\n\n/**\n * Handles the `mouseleave` / `touchend` events when *options.pause*\n * is set to `hover`.\n *\n * @this {HTMLElement | Element}\n */\nfunction carouselResumeHandler() {\n  const element = this;\n  const self = getCarouselInstance(element);\n\n  if (self && self.isPaused && !Timer.get(element, pausedClass)) {\n    self.cycle();\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` indicators.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselIndicatorHandler(e) {\n  e.preventDefault();\n  const indicator = this;\n  const element = closest(indicator, carouselSelector) || getTargetElement(indicator);\n  if (!element) return;\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isAnimating) return;\n\n  // @ts-ignore\n  const newIndex = +getAttribute(indicator, dataBsSlideTo);\n\n  if (indicator && !hasClass(indicator, activeClass) // event target is not active\n    && !Number.isNaN(newIndex)) { // AND has the specific attribute\n    self.to(newIndex); // do the slide\n  }\n}\n\n/**\n * Handles the `click` event for the `Carousel` arrows.\n *\n * @this {HTMLElement}\n * @param {MouseEvent} e the `Event` object\n */\nfunction carouselControlsHandler(e) {\n  e.preventDefault();\n  const control = this;\n  const element = closest(control, carouselSelector) || getTargetElement(control);\n  const self = element && getCarouselInstance(element);\n  if (!self || self.isAnimating) return;\n  const orientation = getAttribute(control, dataBsSlide);\n\n  if (orientation === 'next') {\n    self.next();\n  } else if (orientation === 'prev') {\n    self.prev();\n  }\n}\n\n/**\n * Handles the keyboard `keydown` event for the visible `Carousel` elements.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction carouselKeyHandler({ code }) {\n  const [element] = [...querySelectorAll(carouselSelector)]\n    .filter((x) => isElementInScrollRange(x));\n\n  const self = getCarouselInstance(element);\n  if (!self) return;\n  const RTL = isRTL();\n  const arrowKeyNext = !RTL ? keyArrowRight : keyArrowLeft;\n  const arrowKeyPrev = !RTL ? keyArrowLeft : keyArrowRight;\n\n  if (code === arrowKeyPrev) self.prev();\n  else if (code === arrowKeyNext) self.next();\n}\n\n// CAROUSEL TOUCH HANDLERS\n// =======================\n/**\n * Handles the `touchdown` event for the `Carousel` element.\n *\n * @this {HTMLElement | Element}\n * @param {TouchEvent} e the `Event` object\n */\nfunction carouselTouchDownHandler(e) {\n  const element = this;\n  const self = getCarouselInstance(element);\n\n  if (!self || self.isTouch) { return; }\n\n  startX = e.changedTouches[0].pageX;\n\n  // @ts-ignore\n  if (element.contains(e.target)) {\n    self.isTouch = true;\n    toggleCarouselTouchHandlers(self, true);\n  }\n}\n\n/**\n * Handles the `touchmove` event for the `Carousel` element.\n *\n * @this {HTMLElement | Element}\n * @param {TouchEvent} e\n */\nfunction carouselTouchMoveHandler(e) {\n  const { changedTouches, type } = e;\n  const self = getCarouselInstance(this);\n\n  if (!self || !self.isTouch) { return; }\n\n  currentX = changedTouches[0].pageX;\n\n  // cancel touch if more than one changedTouches detected\n  if (type === touchmoveEvent && changedTouches.length > 1) {\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `touchend` event for the `Carousel` element.\n *\n * @this {HTMLElement | Element}\n\n * @param {TouchEvent} e\n */\nfunction carouselTouchEndHandler(e) {\n  const element = this;\n  const self = getCarouselInstance(element);\n\n  if (!self || !self.isTouch) { return; }\n\n  endX = currentX || e.changedTouches[0].pageX;\n\n  if (self.isTouch) {\n    // the event target is outside the carousel OR carousel doens't include the related target\n    // @ts-ignore\n    if ((!element.contains(e.target) || !element.contains(e.relatedTarget))\n      && Math.abs(startX - endX) < 75) { // AND swipe distance is less than 75px\n      // when the above conditions are satisfied, no need to continue\n      return;\n    } // OR determine next index to slide to\n    if (currentX < startX) {\n      self.index += 1;\n    } else if (currentX > startX) {\n      self.index -= 1;\n    }\n\n    self.isTouch = false;\n    self.to(self.index); // do the slide\n\n    toggleCarouselTouchHandlers(self); // remove touch events handlers\n  }\n}\n\n// CAROUSEL PRIVATE METHODS\n// ========================\n/**\n * Sets active indicator for the `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {number} pageIndex the index of the new active indicator\n */\nfunction activateCarouselIndicator(self, pageIndex) {\n  const { indicators } = self;\n  [...indicators].forEach((x) => removeClass(x, activeClass));\n\n  if (self.indicators[pageIndex]) addClass(indicators[pageIndex], activeClass);\n}\n\n/**\n * Toggles the touch event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselTouchHandlers(self, add) {\n  const { element } = self;\n  const action = add ? addListener : removeListener;\n  action(element, touchmoveEvent, carouselTouchMoveHandler, passiveHandler);\n  action(element, touchendEvent, carouselTouchEndHandler, passiveHandler);\n}\n\n/**\n * Toggles all event listeners for a given `Carousel` instance.\n * @param {Carousel} self the `Carousel` instance\n * @param {boolean=} add when `TRUE` event listeners are added\n */\nfunction toggleCarouselHandlers(self, add) {\n  const {\n    element, options, slides, controls, indicators,\n  } = self;\n  const {\n    touch, pause, interval, keyboard,\n  } = options;\n  const action = add ? addListener : removeListener;\n\n  if (pause && interval) {\n    action(element, mouseenterEvent, carouselPauseHandler);\n    action(element, mouseleaveEvent, carouselResumeHandler);\n    action(element, touchstartEvent, carouselPauseHandler, passiveHandler);\n    action(element, touchendEvent, carouselResumeHandler, passiveHandler);\n  }\n\n  if (touch && slides.length > 1) {\n    action(element, touchstartEvent, carouselTouchDownHandler, passiveHandler);\n  }\n\n  if (controls.length) {\n    controls.forEach((arrow) => {\n      if (arrow) action(arrow, mouseclickEvent, carouselControlsHandler);\n    });\n  }\n\n  if (indicators.length) {\n    indicators.forEach((indicator) => {\n      action(indicator, mouseclickEvent, carouselIndicatorHandler);\n    });\n  }\n  // @ts-ignore\n  if (keyboard) action(getWindow(element), keydownEvent, carouselKeyHandler);\n}\n\n/**\n * Returns the index of the current active item.\n * @param {Carousel} self the `Carousel` instance\n * @returns {number} the query result\n */\nfunction getActiveIndex(self) {\n  const { slides, element } = self;\n  const activeItem = querySelector(`.${carouselItem}.${activeClass}`, element);\n  // @ts-ignore\n  return [...slides].indexOf(activeItem);\n}\n\n// CAROUSEL DEFINITION\n// ===================\n/** Creates a new `Carousel` instance. */\nclass Carousel extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target mostly a `.carousel` element\n   * @param {BSN.Options.Carousel=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // additional properties\n    /** @type {string} */\n    self.direction = isRTL() ? 'right' : 'left';\n    /** @type {number} */\n    self.index = 0;\n    /** @type {boolean} */\n    self.isTouch = false;\n\n    // initialization element\n    const { element } = self;\n    // carousel elements\n    // a LIVE collection is prefferable\n    self.slides = getElementsByClassName(carouselItem, element);\n    const { slides } = self;\n\n    // invalidate when not enough items\n    // no need to go further\n    if (slides.length < 2) { return; }\n\n    self.controls = [\n      ...querySelectorAll(`[${dataBsSlide}]`, element),\n      ...querySelectorAll(`[${dataBsSlide}][${dataBsTarget}=\"#${element.id}\"]`),\n    ];\n\n    /** @type {(HTMLElement | Element)?} */\n    self.indicator = querySelector(`.${carouselString}-indicators`, element);\n\n    // a LIVE collection is prefferable\n    /** @type {(HTMLElement | Element)[]} */\n    self.indicators = [\n      ...(self.indicator ? querySelectorAll(`[${dataBsSlideTo}]`, self.indicator) : []),\n      ...querySelectorAll(`[${dataBsSlideTo}][${dataBsTarget}=\"#${element.id}\"]`),\n    ];\n\n    // set JavaScript and DATA API options\n    const { options } = self;\n\n    // don't use TRUE as interval, it's actually 0, use the default 5000ms better\n    self.options.interval = options.interval === true\n      ? carouselDefaults.interval\n      : options.interval;\n\n    // set first slide active if none\n    if (getActiveIndex(self) < 0) {\n      if (slides.length) addClass(slides[0], activeClass);\n      if (self.indicators.length) activateCarouselIndicator(self, 0);\n    }\n\n    // attach event handlers\n    toggleCarouselHandlers(self, true);\n\n    // start to cycle if interval is set\n    if (options.interval) self.cycle();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return carouselComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return carouselDefaults; }\n  /* eslint-enable */\n\n  /**\n   * Check if instance is paused.\n   * @returns {boolean}\n  */\n  get isPaused() {\n    return hasClass(this.element, pausedClass);\n  }\n\n  /**\n   * Check if instance is animating.\n   * @returns {boolean}\n  */\n  get isAnimating() {\n    return querySelector(`.${carouselItem}-next,.${carouselItem}-prev`, this.element) !== null;\n  }\n\n  // CAROUSEL PUBLIC METHODS\n  // =======================\n  /** Slide automatically through items. */\n  cycle() {\n    const self = this;\n    const { element, options, isPaused } = self;\n\n    Timer.clear(element, carouselString);\n    if (isPaused) {\n      Timer.clear(element, pausedClass);\n      removeClass(element, pausedClass);\n    }\n\n    Timer.set(element, () => {\n      if (!self.isPaused && isElementInScrollRange(element)) {\n        self.index += 1;\n        self.to(self.index);\n      }\n    }, options.interval, carouselString);\n  }\n\n  /** Pause the automatic cycle. */\n  pause() {\n    const self = this;\n    const { element, options } = self;\n    if (!self.isPaused && options.interval) {\n      addClass(element, pausedClass);\n      Timer.set(element, () => {}, 1, pausedClass);\n    }\n  }\n\n  /** Slide to the next item. */\n  next() {\n    const self = this;\n    if (!self.isAnimating) { self.index += 1; self.to(self.index); }\n  }\n\n  /** Slide to the previous item. */\n  prev() {\n    const self = this;\n    if (!self.isAnimating) { self.index -= 1; self.to(self.index); }\n  }\n\n  /**\n   * Jump to the item with the `idx` index.\n   * @param {number} idx the index of the item to jump to\n   */\n  to(idx) {\n    const self = this;\n    const {\n      element, slides, options,\n    } = self;\n    const activeItem = getActiveIndex(self);\n    const RTL = isRTL();\n    let next = idx;\n\n    // when controled via methods, make sure to check again\n    // first return if we're on the same item #227\n    if (self.isAnimating || activeItem === next) return;\n\n    // determine transition direction\n    if ((activeItem < next) || (activeItem === 0 && next === slides.length - 1)) {\n      self.direction = RTL ? 'right' : 'left'; // next\n    } else if ((activeItem > next) || (activeItem === slides.length - 1 && next === 0)) {\n      self.direction = RTL ? 'left' : 'right'; // prev\n    }\n    const { direction } = self;\n\n    // find the right next index\n    if (next < 0) { next = slides.length - 1; } else if (next >= slides.length) { next = 0; }\n\n    // orientation, class name, eventProperties\n    const orientation = direction === 'left' ? 'next' : 'prev';\n    const directionClass = direction === 'left' ? 'start' : 'end';\n\n    const eventProperties = {\n      relatedTarget: slides[next],\n      from: activeItem,\n      to: next,\n      direction,\n    };\n\n    // update event properties\n    ObjectAssign(carouselSlideEvent, eventProperties);\n    ObjectAssign(carouselSlidEvent, eventProperties);\n\n    // discontinue when prevented\n    dispatchEvent(element, carouselSlideEvent);\n    if (carouselSlideEvent.defaultPrevented) return;\n\n    // update index\n    self.index = next;\n    activateCarouselIndicator(self, next);\n\n    if (getElementTransitionDuration(slides[next]) && hasClass(element, 'slide')) {\n      Timer.set(element, () => {\n        addClass(slides[next], `${carouselItem}-${orientation}`);\n        reflow(slides[next]);\n        addClass(slides[next], `${carouselItem}-${directionClass}`);\n        addClass(slides[activeItem], `${carouselItem}-${directionClass}`);\n\n        emulateTransitionEnd(slides[next], () => carouselTransitionEndHandler(self));\n      }, 17, dataBsSlide);\n    } else {\n      addClass(slides[next], activeClass);\n      removeClass(slides[activeItem], activeClass);\n\n      Timer.set(element, () => {\n        Timer.clear(element, dataBsSlide);\n        // check for element, might have been disposed\n        if (element && options.interval && !self.isPaused) {\n          self.cycle();\n        }\n\n        dispatchEvent(element, carouselSlidEvent);\n      }, 17, dataBsSlide);\n    }\n  }\n\n  /** Remove `Carousel` component from target. */\n  dispose() {\n    const self = this;\n    const { slides } = self;\n    const itemClasses = ['start', 'end', 'prev', 'next'];\n\n    [...slides].forEach((slide, idx) => {\n      if (hasClass(slide, activeClass)) activateCarouselIndicator(self, idx);\n      itemClasses.forEach((c) => removeClass(slide, `${carouselItem}-${c}`));\n    });\n\n    toggleCarouselHandlers(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Carousel, {\n  selector: carouselSelector,\n  init: carouselInitCallback,\n  getInstance: getCarouselInstance,\n});\n\n/**\n * A global namespace for aria-expanded.\n * @type {string}\n */\nconst ariaExpanded = 'aria-expanded';\n\n/**\n * Global namespace for most components `collapsing` class.\n * As used by `Collapse` / `Tab`.\n */\nconst collapsingClass = 'collapsing';\n\n/** @type {string} */\nconst collapseString = 'collapse';\n\n/** @type {string} */\nconst collapseComponent = 'Collapse';\n\n/* Native JavaScript for Bootstrap 5 | Collapse\n----------------------------------------------- */\n\n// COLLAPSE GC\n// ===========\nconst collapseSelector = `.${collapseString}`;\nconst collapseToggleSelector = `[${dataBsToggle}=\"${collapseString}\"]`;\nconst collapseDefaults = { parent: null };\n\n/**\n * Static method which returns an existing `Collapse` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Collapse>}\n */\nconst getCollapseInstance = (element) => getInstance(element, collapseComponent);\n\n/**\n * A `Collapse` initialization callback.\n * @type {BSN.InitCallback<Collapse>}\n */\nconst collapseInitCallback = (element) => new Collapse(element);\n\n// COLLAPSE CUSTOM EVENTS\n// ======================\nconst showCollapseEvent = OriginalEvent(`show.bs.${collapseString}`);\nconst shownCollapseEvent = OriginalEvent(`shown.bs.${collapseString}`);\nconst hideCollapseEvent = OriginalEvent(`hide.bs.${collapseString}`);\nconst hiddenCollapseEvent = OriginalEvent(`hidden.bs.${collapseString}`);\n\n// COLLAPSE PRIVATE METHODS\n// ========================\n/**\n * Expand the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction expandCollapse(self) {\n  const {\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, showCollapseEvent);\n  if (showCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  addClass(element, collapsingClass);\n  removeClass(element, collapseString);\n\n  // @ts-ignore\n  element.style.height = `${element.scrollHeight}px`;\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'true'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n    addClass(element, showClass);\n\n    // @ts-ignore\n    element.style.height = '';\n\n    dispatchEvent(element, shownCollapseEvent);\n  });\n}\n\n/**\n * Collapse the designated `Element`.\n * @param {Collapse} self the `Collapse` instance\n */\nfunction collapseContent(self) {\n  const {\n    // @ts-ignore\n    element, parent, triggers,\n  } = self;\n\n  dispatchEvent(element, hideCollapseEvent);\n\n  if (hideCollapseEvent.defaultPrevented) return;\n\n  Timer.set(element, () => {}, 17);\n  if (parent) Timer.set(parent, () => {}, 17);\n\n  // @ts-ignore\n  element.style.height = `${element.scrollHeight}px`;\n\n  removeClass(element, collapseString);\n  removeClass(element, showClass);\n  addClass(element, collapsingClass);\n\n  reflow(element);\n  // @ts-ignore\n  element.style.height = '0px';\n\n  emulateTransitionEnd(element, () => {\n    Timer.clear(element);\n    if (parent) Timer.clear(parent);\n\n    triggers.forEach((btn) => setAttribute(btn, ariaExpanded, 'false'));\n\n    removeClass(element, collapsingClass);\n    addClass(element, collapseString);\n\n    // @ts-ignore\n    element.style.height = '';\n\n    dispatchEvent(element, hiddenCollapseEvent);\n  });\n}\n\n/**\n * Toggles on/off the event listener(s) of the `Collapse` instance.\n * @param {Collapse} self the `Collapse` instance\n * @param {boolean=} add when `true`, the event listener is added\n */\nfunction toggleCollapseHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, collapseClickHandler));\n  }\n}\n\n// COLLAPSE EVENT HANDLER\n// ======================\n/**\n * Handles the `click` event for the `Collapse` instance.\n * @param {MouseEvent} e the `Event` object\n */\nfunction collapseClickHandler(e) {\n  const { target } = e; // @ts-ignore - our target is `HTMLElement`\n  const trigger = target && closest(target, collapseToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getCollapseInstance(element);\n  if (self) self.toggle();\n\n  // event target is anchor link #398\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n// COLLAPSE DEFINITION\n// ===================\n\n/** Returns a new `Colapse` instance. */\nclass Collapse extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target and `Element` that matches the selector\n   * @param {BSN.Options.Collapse=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element, options } = self;\n\n    // set triggering elements\n    /** @type {(HTMLElement | Element)[]} */\n    self.triggers = [...querySelectorAll(collapseToggleSelector)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // set parent accordion\n    /** @type {(HTMLElement | Element)?} */\n    self.parent = querySelector(options.parent);\n\n    // add event listeners\n    toggleCollapseHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return collapseComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return collapseDefaults; }\n  /* eslint-enable */\n\n  // COLLAPSE PUBLIC METHODS\n  // =======================\n  /** Toggles the visibility of the collapse. */\n  toggle() {\n    const self = this;\n    if (!hasClass(self.element, showClass)) self.show();\n    else self.hide();\n  }\n\n  /** Hides the collapse. */\n  hide() {\n    const self = this;\n    const { triggers, element } = self;\n    if (Timer.get(element)) return;\n\n    collapseContent(self);\n    if (triggers.length) {\n      triggers.forEach((btn) => addClass(btn, `${collapseString}d`));\n    }\n  }\n\n  /** Shows the collapse. */\n  show() {\n    const self = this;\n    const {\n      element, parent, triggers,\n    } = self;\n    let activeCollapse;\n    let activeCollapseInstance;\n\n    if (parent) {\n      activeCollapse = [...querySelectorAll(`.${collapseString}.${showClass}`, parent)]\n        .find((i) => getCollapseInstance(i));\n      activeCollapseInstance = activeCollapse && getCollapseInstance(activeCollapse);\n    }\n\n    if ((!parent || (parent && !Timer.get(parent))) && !Timer.get(element)) {\n      if (activeCollapseInstance && activeCollapse !== element) {\n        collapseContent(activeCollapseInstance);\n        activeCollapseInstance.triggers.forEach((btn) => {\n          addClass(btn, `${collapseString}d`);\n        });\n      }\n\n      expandCollapse(self);\n      if (triggers.length) {\n        triggers.forEach((btn) => removeClass(btn, `${collapseString}d`));\n      }\n    }\n  }\n\n  /** Remove the `Collapse` component from the target `Element`. */\n  dispose() {\n    const self = this;\n    toggleCollapseHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Collapse, {\n  selector: collapseSelector,\n  init: collapseInitCallback,\n  getInstance: getCollapseInstance,\n});\n\n/**\n * A global namespace for `focus` event.\n * @type {string}\n */\nconst focusEvent = 'focus';\n\n/**\n * A global namespace for `keyup` event.\n * @type {string}\n */\nconst keyupEvent = 'keyup';\n\n/**\n * A global namespace for `scroll` event.\n * @type {string}\n */\nconst scrollEvent = 'scroll';\n\n/**\n * A global namespace for `resize` event.\n * @type {string}\n */\nconst resizeEvent = 'resize';\n\n/**\n * A global namespace for `ArrowUp` key.\n * @type {string} e.which = 38 equivalent\n */\nconst keyArrowUp = 'ArrowUp';\n\n/**\n * A global namespace for `ArrowDown` key.\n * @type {string} e.which = 40 equivalent\n */\nconst keyArrowDown = 'ArrowDown';\n\n/**\n * A global namespace for `Escape` key.\n * @type {string} e.which = 27 equivalent\n */\nconst keyEscape = 'Escape';\n\n/**\n * Shortcut for `HTMLElement.hasAttribute()` method.\n * @param  {HTMLElement | Element} element target element\n * @param  {string} attribute attribute name\n * @returns {boolean} the query result\n */\nconst hasAttribute = (element, attribute) => element.hasAttribute(attribute);\n\n/**\n * Shortcut for multiple uses of `HTMLElement.style.propertyName` method.\n * @param  {HTMLElement | Element} element target element\n * @param  {Partial<CSSStyleDeclaration>} styles attribute value\n */\n// @ts-ignore\nconst setElementStyle = (element, styles) => { ObjectAssign(element.style, styles); };\n\n/**\n * Utility to focus an `HTMLElement` target.\n *\n * @param {HTMLElement | Element} element is the target\n */\n// @ts-ignore -- `Element`s resulted from querySelector can focus too\nconst focus = (element) => element.focus();\n\n/**\n * Global namespace for `Dropdown` types / classes.\n */\nconst dropdownMenuClasses = ['dropdown', 'dropup', 'dropstart', 'dropend'];\n\n/** @type {string} */\nconst dropdownComponent = 'Dropdown';\n\n/**\n * Global namespace for `.dropdown-menu`.\n */\nconst dropdownMenuClass = 'dropdown-menu';\n\n/**\n * Checks if an *event.target* or its parent has an `href=\"#\"` value.\n * We need to prevent jumping around onclick, don't we?\n *\n * @param {HTMLElement | HTMLAnchorElement | EventTarget} element the target element\n * @returns {boolean} the query result\n */\nfunction isEmptyAnchor(element) {\n  // @ts-ignore -- `EventTarget` must be `HTMLElement`\n  const parentAnchor = closest(element, 'A');\n  // @ts-ignore -- anchor href starts with #\n  return element && ((hasAttribute(element, 'href') && element.href.slice(-1) === '#')\n    // @ts-ignore -- OR a child of an anchor with href starts with #\n    || (parentAnchor && hasAttribute(parentAnchor, 'href') && parentAnchor.href.slice(-1) === '#'));\n}\n\n/* Native JavaScript for Bootstrap 5 | Dropdown\n----------------------------------------------- */\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst [\n  dropdownString,\n  dropupString,\n  dropstartString,\n  dropendString,\n] = dropdownMenuClasses;\nconst dropdownSelector = `[${dataBsToggle}=\"${dropdownString}\"]`;\n\n/**\n * Static method which returns an existing `Dropdown` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Dropdown>}\n */\nconst getDropdownInstance = (element) => getInstance(element, dropdownComponent);\n\n/**\n * A `Dropdown` initialization callback.\n * @type {BSN.InitCallback<Dropdown>}\n */\nconst dropdownInitCallback = (element) => new Dropdown(element);\n\n// DROPDOWN PRIVATE GC\n// ===================\nconst dropdownMenuEndClass = `${dropdownMenuClass}-end`;\nconst verticalClass = [dropdownString, dropupString];\nconst horizontalClass = [dropstartString, dropendString];\nconst menuFocusTags = ['A', 'BUTTON'];\n\nconst dropdownDefaults = {\n  offset: 5, // [number] 5(px)\n  display: 'dynamic', // [dynamic|static]\n};\n\n// DROPDOWN CUSTOM EVENTS\n// ======================\nconst showDropdownEvent = OriginalEvent(`show.bs.${dropdownString}`);\nconst shownDropdownEvent = OriginalEvent(`shown.bs.${dropdownString}`);\nconst hideDropdownEvent = OriginalEvent(`hide.bs.${dropdownString}`);\nconst hiddenDropdownEvent = OriginalEvent(`hidden.bs.${dropdownString}`);\n\n// DROPDOWN PRIVATE METHODS\n// ========================\n/**\n * Apply specific style or class names to a `.dropdown-menu` to automatically\n * accomodate the layout and the page scroll.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction styleDropdown(self) {\n  const {\n    element, menu, parentElement, options,\n  } = self;\n  const { offset } = options;\n\n  // don't apply any style on mobile view\n  if (getElementStyle(menu, 'position') === 'static') return;\n\n  const RTL = isRTL(element);\n  const menuEnd = hasClass(parentElement, dropdownMenuEndClass);\n\n  // reset menu offset and position\n  const resetProps = ['margin', 'top', 'bottom', 'left', 'right'];\n  // @ts-ignore\n  resetProps.forEach((p) => { menu.style[p] = ''; });\n\n  // set initial position class\n  // take into account .btn-group parent as .dropdown\n  let positionClass = dropdownMenuClasses.find((c) => hasClass(parentElement, c)) || dropdownString;\n\n  /** @type {Record<string, Record<string, any>>} */\n  let dropdownMargin = {\n    dropdown: [offset, 0, 0],\n    dropup: [0, 0, offset],\n    dropstart: RTL ? [-1, 0, 0, offset] : [-1, offset, 0],\n    dropend: RTL ? [-1, offset, 0] : [-1, 0, 0, offset],\n  };\n\n  /** @type {Record<string, Record<string, any>>} */\n  const dropdownPosition = {\n    dropdown: { top: '100%' },\n    dropup: { top: 'auto', bottom: '100%' },\n    dropstart: RTL ? { left: '100%', right: 'auto' } : { left: 'auto', right: '100%' },\n    dropend: RTL ? { left: 'auto', right: '100%' } : { left: '100%', right: 'auto' },\n    menuEnd: RTL ? { right: 'auto', left: 0 } : { right: 0, left: 'auto' },\n  };\n\n  // @ts-ignore\n  const { offsetWidth: menuWidth, offsetHeight: menuHeight } = menu;\n\n  const { clientWidth, clientHeight } = getDocumentElement(element);\n  const {\n    left: targetLeft, top: targetTop,\n    width: targetWidth, height: targetHeight,\n  } = getBoundingClientRect(element);\n\n  // dropstart | dropend\n  const leftFullExceed = targetLeft - menuWidth - offset < 0;\n  // dropend\n  const rightFullExceed = targetLeft + menuWidth + targetWidth + offset >= clientWidth;\n  // dropstart | dropend\n  const bottomExceed = targetTop + menuHeight + offset >= clientHeight;\n  // dropdown\n  const bottomFullExceed = targetTop + menuHeight + targetHeight + offset >= clientHeight;\n  // dropup\n  const topExceed = targetTop - menuHeight - offset < 0;\n  // dropdown / dropup\n  const leftExceed = ((!RTL && menuEnd) || (RTL && !menuEnd))\n    && targetLeft + targetWidth - menuWidth < 0;\n  const rightExceed = ((RTL && menuEnd) || (!RTL && !menuEnd))\n    && targetLeft + menuWidth >= clientWidth;\n\n  // recompute position\n  // handle RTL as well\n  if (horizontalClass.includes(positionClass) && leftFullExceed && rightFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropstartString && (!RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropendString;\n  }\n  if (positionClass === dropendString && (RTL ? leftFullExceed : rightFullExceed)) {\n    positionClass = dropstartString;\n  }\n  if (positionClass === dropupString && topExceed && !bottomFullExceed) {\n    positionClass = dropdownString;\n  }\n  if (positionClass === dropdownString && bottomFullExceed && !topExceed) {\n    positionClass = dropupString;\n  }\n  // override position for horizontal classes\n  if (horizontalClass.includes(positionClass) && bottomExceed) {\n    ObjectAssign(dropdownPosition[positionClass], {\n      top: 'auto', bottom: 0,\n    });\n  }\n  // override position for vertical classes\n  if (verticalClass.includes(positionClass) && (leftExceed || rightExceed)) {\n    // don't realign when menu is wider than window\n    // in both RTL and non-RTL readability is KING\n    if (targetLeft + targetWidth + Math.abs(menuWidth - targetWidth) + offset < clientWidth) {\n      ObjectAssign(dropdownPosition[positionClass],\n        leftExceed ? { left: 0, right: 'auto' } : { left: 'auto', right: 0 });\n    }\n  }\n\n  dropdownMargin = dropdownMargin[positionClass];\n  // @ts-ignore\n  menu.style.margin = `${dropdownMargin.map((x) => (x ? `${x}px` : x)).join(' ')}`;\n\n  setElementStyle(menu, dropdownPosition[positionClass]);\n\n  // update dropdown-menu-end\n  if (hasClass(menu, dropdownMenuEndClass)) {\n    setElementStyle(menu, dropdownPosition.menuEnd);\n  }\n}\n\n/**\n * Returns an `Array` of focusable items in the given dropdown-menu.\n * @param {HTMLElement | Element} menu\n * @returns {(HTMLElement | Element)[]}\n */\nfunction getMenuItems(menu) {\n  // @ts-ignore\n  return [...menu.children].map((c) => {\n    if (c && menuFocusTags.includes(c.tagName)) return c;\n    const { firstElementChild } = c;\n    if (firstElementChild && menuFocusTags.includes(firstElementChild.tagName)) {\n      return firstElementChild;\n    }\n    return null;\n  }).filter((c) => c);\n}\n\n/**\n * Toggles on/off the listeners for the events that close the dropdown\n * as well as event that request a new position for the dropdown.\n *\n * @param {Dropdown} self the `Dropdown` instance\n */\nfunction toggleDropdownDismiss(self) {\n  const { element } = self;\n  const action = self.open ? addListener : removeListener;\n  const doc = getDocument(element);\n\n  action(doc, mouseclickEvent, dropdownDismissHandler);\n  action(doc, focusEvent, dropdownDismissHandler);\n  action(doc, keydownEvent, dropdownPreventScroll);\n  action(doc, keyupEvent, dropdownKeyHandler);\n\n  if (self.options.display === 'dynamic') {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      // @ts-ignore\n      action(getWindow(element), ev, dropdownLayoutHandler, passiveHandler);\n    });\n  }\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Dropdown`.\n *\n * @param {Dropdown} self the `Dropdown` instance\n * @param {boolean=} add when `true`, it will add the event listener\n */\nfunction toggleDropdownHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, dropdownClickHandler);\n}\n\n/**\n * Returns the currently open `.dropdown` element.\n *\n * @param {(Document | HTMLElement | Element | globalThis)=} element target\n * @returns {HTMLElement?} the query result\n */\nfunction getCurrentOpenDropdown(element) {\n  const currentParent = [...dropdownMenuClasses, 'btn-group', 'input-group']\n    .map((c) => getElementsByClassName(`${c} ${showClass}`), getDocument(element))\n    .find((x) => x.length);\n\n  if (currentParent && currentParent.length) {\n    // @ts-ignore -- HTMLElement is also Element\n    return [...currentParent[0].children]\n      .find((x) => hasAttribute(x, dataBsToggle));\n  }\n  return null;\n}\n\n// DROPDOWN EVENT HANDLERS\n// =======================\n/**\n * Handles the `click` event for the `Dropdown` instance.\n *\n * @param {MouseEvent} e event object\n * @this {Document}\n */\nfunction dropdownDismissHandler(e) {\n  const { target, type } = e;\n  // @ts-ignore\n  if (!target || !target.closest) return; // some weird FF bug #409\n\n  // @ts-ignore\n  const element = getCurrentOpenDropdown(target);\n  if (!element) return;\n\n  const self = getDropdownInstance(element);\n  if (!self) return;\n\n  const { parentElement, menu } = self;\n\n  // @ts-ignore\n  const hasData = closest(target, dropdownSelector) !== null;\n  // @ts-ignore\n  const isForm = parentElement && parentElement.contains(target)\n    // @ts-ignore\n    && (target.tagName === 'form' || closest(target, 'form') !== null);\n\n  // @ts-ignore\n  if (type === mouseclickEvent && isEmptyAnchor(target)) {\n    e.preventDefault();\n  }\n  if (type === focusEvent // @ts-ignore\n    && (target === element || target === menu || menu.contains(target))) {\n    return;\n  }\n\n  if (isForm || hasData) ; else if (self) {\n    self.hide();\n  }\n}\n\n/**\n * Handles `click` event listener for `Dropdown`.\n * @this {HTMLElement | Element}\n * @param {MouseEvent} e event object\n */\nfunction dropdownClickHandler(e) {\n  const element = this;\n  const { target } = e;\n  const self = getDropdownInstance(element);\n\n  if (self) {\n    self.toggle();\n    if (target && isEmptyAnchor(target)) e.preventDefault();\n  }\n}\n\n/**\n * Prevents scroll when dropdown-menu is visible.\n * @param {KeyboardEvent} e event object\n */\nfunction dropdownPreventScroll(e) {\n  if ([keyArrowDown, keyArrowUp].includes(e.code)) e.preventDefault();\n}\n\n/**\n * Handles keyboard `keydown` events for `Dropdown`.\n * @param {KeyboardEvent} e keyboard key\n * @this {Document}\n */\nfunction dropdownKeyHandler(e) {\n  const { code } = e;\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n  const activeItem = element && getDocument(element).activeElement;\n  if (!self || !activeItem) return;\n  const { menu, open } = self;\n  const menuItems = getMenuItems(menu);\n\n  // arrow up & down\n  if (menuItems && menuItems.length && [keyArrowDown, keyArrowUp].includes(code)) {\n    let idx = menuItems.indexOf(activeItem);\n    if (activeItem === element) {\n      idx = 0;\n    } else if (code === keyArrowUp) {\n      idx = idx > 1 ? idx - 1 : 0;\n    } else if (code === keyArrowDown) {\n      idx = idx < menuItems.length - 1 ? idx + 1 : idx;\n    }\n    if (menuItems[idx]) focus(menuItems[idx]);\n  }\n\n  if (keyEscape === code && open) {\n    self.toggle();\n    focus(element);\n  }\n}\n\n/**\n * @this {globalThis}\n * @returns {void}\n */\nfunction dropdownLayoutHandler() {\n  const element = getCurrentOpenDropdown(this);\n  const self = element && getDropdownInstance(element);\n\n  if (self && self.open) styleDropdown(self);\n}\n\n// DROPDOWN DEFINITION\n// ===================\n/** Returns a new Dropdown instance. */\nclass Dropdown extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target Element or string selector\n   * @param {BSN.Options.Dropdown=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const { parentElement } = element;\n\n    // set targets\n    /** @type {(Element | HTMLElement)} */\n    // @ts-ignore\n    self.parentElement = parentElement;\n    /** @type {(Element | HTMLElement)} */\n    // @ts-ignore\n    self.menu = querySelector(`.${dropdownMenuClass}`, parentElement);\n\n    // set initial state to closed\n    /** @type {boolean} */\n    self.open = false;\n\n    // add event listener\n    toggleDropdownHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return dropdownComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return dropdownDefaults; }\n  /* eslint-enable */\n\n  // DROPDOWN PUBLIC METHODS\n  // =======================\n  /** Shows/hides the dropdown menu to the user. */\n  toggle() {\n    const self = this;\n\n    if (self.open) self.hide();\n    else self.show();\n  }\n\n  /** Shows the dropdown menu to the user. */\n  show() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n\n    const currentElement = getCurrentOpenDropdown(element);\n    const currentInstance = currentElement && getDropdownInstance(currentElement);\n    if (currentInstance) currentInstance.hide();\n\n    // dispatch\n    [showDropdownEvent, shownDropdownEvent].forEach((e) => { e.relatedTarget = element; });\n    dispatchEvent(parentElement, showDropdownEvent);\n    if (showDropdownEvent.defaultPrevented) return;\n\n    addClass(menu, showClass);\n    addClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'true');\n\n    // change menu position\n    styleDropdown(self);\n\n    self.open = !open;\n\n    setTimeout(() => {\n      focus(element); // focus the element\n      toggleDropdownDismiss(self);\n      dispatchEvent(parentElement, shownDropdownEvent);\n    }, 1);\n  }\n\n  /** Hides the dropdown menu from the user. */\n  hide() {\n    const self = this;\n    const {\n      element, open, menu, parentElement,\n    } = self;\n    [hideDropdownEvent, hiddenDropdownEvent].forEach((e) => { e.relatedTarget = element; });\n\n    dispatchEvent(parentElement, hideDropdownEvent);\n    if (hideDropdownEvent.defaultPrevented) return;\n\n    removeClass(menu, showClass);\n    removeClass(parentElement, showClass);\n    setAttribute(element, ariaExpanded, 'false');\n\n    self.open = !open;\n\n    // only re-attach handler if the instance is not disposed\n    setTimeout(() => toggleDropdownDismiss(self), 1);\n\n    dispatchEvent(parentElement, hiddenDropdownEvent);\n  }\n\n  /** Removes the `Dropdown` component from the target element. */\n  dispose() {\n    const self = this;\n    const { parentElement } = self;\n\n    if (hasClass(parentElement, showClass) && self.open) self.hide();\n\n    toggleDropdownHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Dropdown, {\n  selector: dropdownSelector,\n  init: dropdownInitCallback,\n  getInstance: getDropdownInstance,\n});\n\n/**\n * A global namespace for aria-hidden.\n * @type {string}\n */\nconst ariaHidden = 'aria-hidden';\n\n/**\n * A global namespace for aria-modal.\n * @type {string}\n */\nconst ariaModal = 'aria-modal';\n\n/**\n * Shortcut for `HTMLElement.removeAttribute()` method.\n * @param  {HTMLElement | Element} element target element\n * @param  {string} attribute attribute name\n * @returns {void}\n */\nconst removeAttribute = (element, attribute) => element.removeAttribute(attribute);\n\n/**\n * Returns the `document.body` or the `<body>` element.\n *\n * @param {(Node | HTMLElement | Element | globalThis)=} node\n * @returns {HTMLElement | HTMLBodyElement}\n */\nfunction getDocumentBody(node) {\n  return getDocument(node).body;\n}\n\n/** @type {string} */\nconst modalString = 'modal';\n\n/** @type {string} */\nconst modalComponent = 'Modal';\n\n/**\n * Check if target is a `ShadowRoot`.\n *\n * @param {any} element target\n * @returns {boolean} the query result\n */\nconst isShadowRoot = (element) => {\n  const OwnElement = getWindow(element).ShadowRoot;\n  return element instanceof OwnElement || element instanceof ShadowRoot;\n};\n\n/**\n * Returns the `parentNode` also going through `ShadowRoot`.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {Node | HTMLElement | Element} node the target node\n * @returns {Node | HTMLElement | Element} the apropriate parent node\n */\nfunction getParentNode(node) {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  return (\n    // @ts-ignore\n    node.assignedSlot // step into the shadow DOM of the parent of a slotted node\n    || node.parentNode // @ts-ignore DOM Element detected\n    || (isShadowRoot(node) ? node.host : null) // ShadowRoot detected\n    || getDocumentElement(node) // fallback\n  );\n}\n\n/**\n * Check if a target element is a `<table>`, `<td>` or `<th>`.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isTableElement = (element) => ['TABLE', 'TD', 'TH'].includes(element.tagName);\n\n/**\n * Checks if an element is an `HTMLElement`.\n *\n * @param {any} element the target object\n * @returns {boolean} the query result\n */\nconst isHTMLElement = (element) => element instanceof HTMLElement;\n\n/**\n * Returns an `HTMLElement` to be used as default value for *options.container*\n * for `Tooltip` / `Popover` components.\n *\n * When `getOffset` is *true*, it returns the `offsetParent` for tooltip/popover\n * offsets computation similar to **floating-ui**.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Element} element the target\n * @param {boolean=} getOffset when *true* it will return an `offsetParent`\n * @returns {HTMLElement | HTMLBodyElement | Window | globalThis} the query result\n */\nfunction getElementContainer(element, getOffset) {\n  const majorBlockTags = ['HTML', 'BODY'];\n\n  if (getOffset) {\n    /** @type {any} */\n    let { offsetParent } = element;\n    const win = getWindow(element);\n    // const { innerWidth } = getDocumentElement(element);\n\n    while (offsetParent && (isTableElement(offsetParent)\n      || (isHTMLElement(offsetParent)\n        // we must count for both fixed & sticky\n        && !['sticky', 'fixed'].includes(getElementStyle(offsetParent, 'position'))))) {\n      offsetParent = offsetParent.offsetParent;\n    }\n\n    if (!offsetParent || (offsetParent\n      && (majorBlockTags.includes(offsetParent.tagName)\n        || getElementStyle(offsetParent, 'position') === 'static'))) {\n      offsetParent = win;\n    }\n    return offsetParent;\n  }\n\n  /** @type {(HTMLElement)[]} */\n  const containers = [];\n  /** @type {any} */\n  let { parentNode } = element;\n\n  while (parentNode && !majorBlockTags.includes(parentNode.nodeName)) {\n    parentNode = getParentNode(parentNode);\n    if (!(isShadowRoot(parentNode) || !!parentNode.shadowRoot\n      || isTableElement(parentNode))) {\n      containers.push(parentNode);\n    }\n  }\n\n  return containers.find((c, i) => {\n    if (getElementStyle(c, 'position') !== 'relative'\n      && containers.slice(i + 1).every((r) => getElementStyle(r, 'position') === 'static')) {\n      return c;\n    }\n    return null;\n  }) || getDocumentBody(element);\n}\n\n/**\n * Global namespace for components `fixed-top` class.\n */\nconst fixedTopClass = 'fixed-top';\n\n/**\n * Global namespace for components `fixed-bottom` class.\n */\nconst fixedBottomClass = 'fixed-bottom';\n\n/**\n * Global namespace for components `sticky-top` class.\n */\nconst stickyTopClass = 'sticky-top';\n\n/**\n * Global namespace for components `position-sticky` class.\n */\nconst positionStickyClass = 'position-sticky';\n\n/** @param {(HTMLElement | Element | Document)=} parent */\nconst getFixedItems = (parent) => [\n  ...getElementsByClassName(fixedTopClass, parent),\n  ...getElementsByClassName(fixedBottomClass, parent),\n  ...getElementsByClassName(stickyTopClass, parent),\n  ...getElementsByClassName(positionStickyClass, parent),\n  ...getElementsByClassName('is-fixed', parent),\n];\n\n/**\n * Removes *padding* and *overflow* from the `<body>`\n * and all spacing from fixed items.\n * @param {(HTMLElement | Element)=} element the target modal/offcanvas\n */\nfunction resetScrollbar(element) {\n  const bd = getDocumentBody(element);\n  setElementStyle(bd, {\n    paddingRight: '',\n    overflow: '',\n  });\n\n  const fixedItems = getFixedItems(bd);\n\n  if (fixedItems.length) {\n    fixedItems.forEach((fixed) => {\n      setElementStyle(fixed, {\n        paddingRight: '',\n        marginRight: '',\n      });\n    });\n  }\n}\n\n/**\n * Returns the scrollbar width if the body does overflow\n * the window.\n * @param {(HTMLElement | Element)=} element\n * @returns {number} the value\n */\nfunction measureScrollbar(element) {\n  const { clientWidth } = getDocumentElement(element);\n  const { innerWidth } = getWindow(element);\n  return Math.abs(innerWidth - clientWidth);\n}\n\n/**\n * Sets the `<body>` and fixed items style when modal / offcanvas\n * is shown to the user.\n *\n * @param {HTMLElement | Element} element the target modal/offcanvas\n * @param {boolean=} overflow body does overflow or not\n */\nfunction setScrollbar(element, overflow) {\n  const bd = getDocumentBody(element);\n  const bodyPad = parseInt(getElementStyle(bd, 'paddingRight'), 10);\n  const isOpen = getElementStyle(bd, 'overflow') === 'hidden';\n  const sbWidth = isOpen && bodyPad ? 0 : measureScrollbar(element);\n  const fixedItems = getFixedItems(bd);\n\n  if (overflow) {\n    setElementStyle(bd, {\n      overflow: 'hidden',\n      paddingRight: `${bodyPad + sbWidth}px`,\n    });\n\n    if (fixedItems.length) {\n      fixedItems.forEach((fixed) => {\n        const itemPadValue = getElementStyle(fixed, 'paddingRight');\n        // @ts-ignore\n        fixed.style.paddingRight = `${parseInt(itemPadValue, 10) + sbWidth}px`;\n        if ([stickyTopClass, positionStickyClass].some((c) => hasClass(fixed, c))) {\n          const itemMValue = getElementStyle(fixed, 'marginRight');\n          // @ts-ignore\n          fixed.style.marginRight = `${parseInt(itemMValue, 10) - sbWidth}px`;\n        }\n      });\n    }\n  }\n}\n\n/**\n * This is a shortie for `document.createElement` method\n * which allows you to create a new `HTMLElement` for a given `tagName`\n * or based on an object with specific non-readonly attributes:\n * `id`, `className`, `textContent`, `style`, etc.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\n *\n * @param {Record<string, string> | string} param `tagName` or object\n * @return {HTMLElement | Element} a new `HTMLElement` or `Element`\n */\nfunction createElement(param) {\n  if (typeof param === 'string') {\n    return getDocument().createElement(param);\n  }\n\n  const { tagName } = param;\n  const attr = { ...param };\n  const newElement = createElement(tagName);\n  delete attr.tagName;\n  ObjectAssign(newElement, attr);\n  return newElement;\n}\n\n/** @type {string} */\nconst offcanvasString = 'offcanvas';\n\nconst backdropString = 'backdrop';\nconst modalBackdropClass = `${modalString}-${backdropString}`;\nconst offcanvasBackdropClass = `${offcanvasString}-${backdropString}`;\nconst modalActiveSelector = `.${modalString}.${showClass}`;\nconst offcanvasActiveSelector = `.${offcanvasString}.${showClass}`;\n\n// any document would suffice\nconst overlay = createElement('div');\n\n/**\n * Returns the current active modal / offcancas element.\n * @param {(HTMLElement | Element)=} element the context element\n * @returns {(HTMLElement | Element)?} the requested element\n */\nfunction getCurrentOpen(element) {\n  return querySelector(`${modalActiveSelector},${offcanvasActiveSelector}`, getDocument(element));\n}\n\n/**\n * Toogles from a Modal overlay to an Offcanvas, or vice-versa.\n * @param {boolean=} isModal\n */\nfunction toggleOverlayType(isModal) {\n  const targetClass = isModal ? modalBackdropClass : offcanvasBackdropClass;\n  [modalBackdropClass, offcanvasBackdropClass].forEach((c) => {\n    removeClass(overlay, c);\n  });\n  addClass(overlay, targetClass);\n}\n\n/**\n * Append the overlay to DOM.\n * @param {HTMLElement | Element} container\n * @param {boolean} hasFade\n * @param {boolean=} isModal\n */\nfunction appendOverlay(container, hasFade, isModal) {\n  toggleOverlayType(isModal);\n  container.append(overlay);\n  if (hasFade) addClass(overlay, fadeClass);\n}\n\n/**\n * Shows the overlay to the user.\n */\nfunction showOverlay() {\n  if (!hasClass(overlay, showClass)) {\n    addClass(overlay, showClass);\n    reflow(overlay);\n  }\n}\n\n/**\n * Hides the overlay from the user.\n */\nfunction hideOverlay() {\n  removeClass(overlay, showClass);\n}\n\n/**\n * Removes the overlay from DOM.\n * @param {(HTMLElement | Element)=} element\n */\nfunction removeOverlay(element) {\n  if (!getCurrentOpen(element)) {\n    removeClass(overlay, fadeClass);\n    overlay.remove();\n    resetScrollbar(element);\n  }\n}\n\n/**\n * @param {HTMLElement | Element} element target\n * @returns {boolean}\n */\nfunction isVisible(element) {\n  return element && getElementStyle(element, 'visibility') !== 'hidden'\n    // @ts-ignore\n    && element.offsetParent !== null;\n}\n\n/* Native JavaScript for Bootstrap 5 | Modal\n-------------------------------------------- */\n\n// MODAL PRIVATE GC\n// ================\nconst modalSelector = `.${modalString}`;\nconst modalToggleSelector = `[${dataBsToggle}=\"${modalString}\"]`;\nconst modalDismissSelector = `[${dataBsDismiss}=\"${modalString}\"]`;\nconst modalStaticClass = `${modalString}-static`;\n\nconst modalDefaults = {\n  backdrop: true, // boolean|string\n  keyboard: true, // boolean\n};\n\n/**\n * Static method which returns an existing `Modal` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Modal>}\n */\nconst getModalInstance = (element) => getInstance(element, modalComponent);\n\n/**\n * A `Modal` initialization callback.\n * @type {BSN.InitCallback<Modal>}\n */\nconst modalInitCallback = (element) => new Modal(element);\n\n// MODAL CUSTOM EVENTS\n// ===================\nconst showModalEvent = OriginalEvent(`show.bs.${modalString}`);\nconst shownModalEvent = OriginalEvent(`shown.bs.${modalString}`);\nconst hideModalEvent = OriginalEvent(`hide.bs.${modalString}`);\nconst hiddenModalEvent = OriginalEvent(`hidden.bs.${modalString}`);\n\n// MODAL PRIVATE METHODS\n// =====================\n/**\n * Applies special style for the `<body>` and fixed elements\n * when a modal instance is shown to the user.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction setModalScrollbar(self) {\n  const { element } = self;\n  const scrollbarWidth = measureScrollbar(element);\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  const { clientHeight: modalHeight, scrollHeight: modalScrollHeight } = element;\n  const modalOverflow = modalHeight !== modalScrollHeight;\n\n  if (!modalOverflow && scrollbarWidth) {\n    const pad = isRTL(element) ? 'paddingLeft' : 'paddingRight';\n    // @ts-ignore -- cannot use `setElementStyle`\n    element.style[pad] = `${scrollbarWidth}px`;\n  }\n  setScrollbar(element, (modalOverflow || clientHeight !== scrollHeight));\n}\n\n/**\n * Toggles on/off the listeners of events that close the modal.\n *\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleModalDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n  action(element, mouseclickEvent, modalDismissHandler);\n  // @ts-ignore\n  action(getWindow(element), resizeEvent, self.update, passiveHandler);\n  action(getDocument(element), keydownEvent, modalKeyHandler);\n}\n\n/**\n * Toggles on/off the `click` event listener of the `Modal` instance.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleModalHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  const { triggers } = self;\n\n  if (triggers.length) {\n    triggers.forEach((btn) => action(btn, mouseclickEvent, modalClickHandler));\n  }\n}\n\n/**\n * Executes after a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalHide(self) {\n  const { triggers, element, relatedTarget } = self;\n  removeOverlay(element);\n  setElementStyle(element, { paddingRight: '' });\n  toggleModalDismiss(self);\n\n  const focusElement = showModalEvent.relatedTarget || triggers.find(isVisible);\n  if (focusElement) focus(focusElement);\n\n  hiddenModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, hiddenModalEvent);\n}\n\n/**\n * Executes after a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction afterModalShow(self) {\n  const { element, relatedTarget } = self;\n  focus(element);\n  toggleModalDismiss(self, true);\n\n  shownModalEvent.relatedTarget = relatedTarget;\n  dispatchEvent(element, shownModalEvent);\n}\n\n/**\n * Executes before a modal is shown to the user.\n * @param {Modal} self the `Modal` instance\n */\nfunction beforeModalShow(self) {\n  const { element, hasFade } = self;\n  setElementStyle(element, { display: 'block' });\n\n  setModalScrollbar(self);\n  if (!getCurrentOpen(element)) {\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, showClass);\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n\n  if (hasFade) emulateTransitionEnd(element, () => afterModalShow(self));\n  else afterModalShow(self);\n}\n\n/**\n * Executes before a modal is hidden to the user.\n * @param {Modal} self the `Modal` instance\n * @param {boolean=} force when `true` skip animation\n */\nfunction beforeModalHide(self, force) {\n  const {\n    element, options, hasFade,\n  } = self;\n\n  setElementStyle(element, { display: '' });\n\n  // force can also be the transitionEvent object, we wanna make sure it's not\n  // call is not forced and overlay is visible\n  if (options.backdrop && !force && hasFade && hasClass(overlay, showClass)\n    && !getCurrentOpen(element)) { // AND no modal is visible\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => afterModalHide(self));\n  } else {\n    afterModalHide(self);\n  }\n}\n\n// MODAL EVENT HANDLERS\n// ====================\n/**\n * Handles the `click` event listener for modal.\n * @param {MouseEvent} e the `Event` object\n * @this {HTMLElement | Element}\n */\nfunction modalClickHandler(e) {\n  const { target } = e;\n\n  const trigger = target && closest(this, modalToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getModalInstance(element);\n\n  if (!self) return;\n\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n  self.relatedTarget = trigger;\n  self.toggle();\n}\n\n/**\n * Handles the `keydown` event listener for modal\n * to hide the modal when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n */\nfunction modalKeyHandler({ code }) {\n  const element = querySelector(modalActiveSelector);\n  const self = element && getModalInstance(element);\n  if (!self) return;\n  const { options } = self;\n  if (options.keyboard && code === keyEscape // the keyboard option is enabled and the key is 27\n    && hasClass(element, showClass)) { // the modal is not visible\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `click` event listeners that hide the modal.\n *\n * @this {HTMLElement | Element}\n * @param {MouseEvent} e the `Event` object\n */\nfunction modalDismissHandler(e) {\n  const element = this;\n  const self = getModalInstance(element);\n\n  // this timer is needed\n  if (!self || Timer.get(element)) return;\n\n  const { options, isStatic, modalDialog } = self;\n  const { backdrop } = options;\n  const { target } = e;\n\n  // @ts-ignore\n  const selectedText = getDocument(element).getSelection().toString().length;\n  // @ts-ignore\n  const targetInsideDialog = modalDialog.contains(target);\n  // @ts-ignore\n  const dismiss = target && closest(target, modalDismissSelector);\n\n  if (isStatic && !targetInsideDialog) {\n    Timer.set(element, () => {\n      addClass(element, modalStaticClass);\n      emulateTransitionEnd(modalDialog, () => staticTransitionEnd(self));\n    }, 17);\n  } else if (dismiss || (!selectedText && !isStatic && !targetInsideDialog && backdrop)) {\n    self.relatedTarget = dismiss || null;\n    self.hide();\n    e.preventDefault();\n  }\n}\n\n/**\n * Handles the `transitionend` event listeners for `Modal`.\n *\n * @param {Modal} self the `Modal` instance\n */\nfunction staticTransitionEnd(self) {\n  const { element, modalDialog } = self;\n  const duration = getElementTransitionDuration(modalDialog) + 17;\n  removeClass(element, modalStaticClass);\n  // user must wait for zoom out transition\n  Timer.set(element, () => Timer.clear(element), duration);\n}\n\n// MODAL DEFINITION\n// ================\n/** Returns a new `Modal` instance. */\nclass Modal extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target usually the `.modal` element\n   * @param {BSN.Options.Modal=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n\n    // the modal\n    const { element } = self;\n\n    // the modal-dialog\n    /** @type {(HTMLElement | Element)} */\n    // @ts-ignore\n    self.modalDialog = querySelector(`.${modalString}-dialog`, element);\n\n    // modal can have multiple triggering elements\n    /** @type {(HTMLElement | Element)[]} */\n    self.triggers = [...querySelectorAll(modalToggleSelector)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional internals\n    /** @type {boolean} */\n    self.isStatic = self.options.backdrop === 'static';\n    /** @type {boolean} */\n    self.hasFade = hasClass(element, fadeClass);\n    /** @type {(HTMLElement | Element)?} */\n    self.relatedTarget = null;\n    /** @type {HTMLBodyElement | HTMLElement | Element} */\n    // @ts-ignore\n    self.container = getElementContainer(element);\n\n    // attach event listeners\n    toggleModalHandler(self, true);\n\n    // bind\n    self.update = self.update.bind(self);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return modalComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return modalDefaults; }\n  /* eslint-enable */\n\n  // MODAL PUBLIC METHODS\n  // ====================\n  /** Toggles the visibility of the modal. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the modal to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, hasFade, relatedTarget, container,\n    } = self;\n    const { backdrop } = options;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, showModalEvent);\n    if (showModalEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getModalInstance(currentOpen);\n      const that1 = this1 || getInstance(currentOpen, 'Offcanvas');\n      that1.hide();\n    }\n\n    if (backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, hasFade, true);\n      } else {\n        toggleOverlayType(true);\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n\n      showOverlay();\n      setTimeout(() => beforeModalShow(self), overlayDelay);\n    } else {\n      beforeModalShow(self);\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hide the modal from the user.\n   * @param {boolean=} force when `true` it will skip animation\n   */\n  hide(force) {\n    const self = this;\n    const {\n      element, hasFade, relatedTarget,\n    } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideModalEvent.relatedTarget = relatedTarget || null;\n    dispatchEvent(element, hideModalEvent);\n    if (hideModalEvent.defaultPrevented) return;\n    removeClass(element, showClass);\n    setAttribute(element, ariaHidden, 'true');\n    removeAttribute(element, ariaModal);\n\n    if (hasFade && force !== false) {\n      emulateTransitionEnd(element, () => beforeModalHide(self));\n    } else {\n      beforeModalHide(self, force);\n    }\n  }\n\n  /** Updates the modal layout. */\n  update() {\n    const self = this;\n\n    if (hasClass(self.element, showClass)) setModalScrollbar(self);\n  }\n\n  /** Removes the `Modal` component from target element. */\n  dispose() {\n    const self = this;\n    self.hide(true); // forced call\n\n    toggleModalHandler(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Modal, {\n  selector: modalSelector,\n  init: modalInitCallback,\n  getInstance: getModalInstance,\n});\n\n/** @type {string} */\nconst offcanvasComponent = 'Offcanvas';\n\n/* Native JavaScript for Bootstrap 5 | OffCanvas\n------------------------------------------------ */\n\n// OFFCANVAS PRIVATE GC\n// ====================\nconst offcanvasSelector = `.${offcanvasString}`;\nconst offcanvasToggleSelector = `[${dataBsToggle}=\"${offcanvasString}\"]`;\nconst offcanvasDismissSelector = `[${dataBsDismiss}=\"${offcanvasString}\"]`;\nconst offcanvasTogglingClass = `${offcanvasString}-toggling`;\n\nconst offcanvasDefaults = {\n  backdrop: true, // boolean\n  keyboard: true, // boolean\n  scroll: false, // boolean\n};\n\n/**\n * Static method which returns an existing `Offcanvas` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Offcanvas>}\n */\nconst getOffcanvasInstance = (element) => getInstance(element, offcanvasComponent);\n\n/**\n * An `Offcanvas` initialization callback.\n * @type {BSN.InitCallback<Offcanvas>}\n */\nconst offcanvasInitCallback = (element) => new Offcanvas(element);\n\n// OFFCANVAS CUSTOM EVENTS\n// =======================\nconst showOffcanvasEvent = OriginalEvent(`show.bs.${offcanvasString}`);\nconst shownOffcanvasEvent = OriginalEvent(`shown.bs.${offcanvasString}`);\nconst hideOffcanvasEvent = OriginalEvent(`hide.bs.${offcanvasString}`);\nconst hiddenOffcanvasEvent = OriginalEvent(`hidden.bs.${offcanvasString}`);\n\n// OFFCANVAS PRIVATE METHODS\n// =========================\n/**\n * Sets additional style for the `<body>` and other elements\n * when showing an offcanvas to the user.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction setOffCanvasScrollbar(self) {\n  const { element } = self;\n  const { clientHeight, scrollHeight } = getDocumentElement(element);\n  setScrollbar(element, clientHeight !== scrollHeight);\n}\n\n/**\n * Toggles on/off the `click` event listeners.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true*, listeners are added\n */\nfunction toggleOffcanvasEvents(self, add) {\n  const action = add ? addListener : removeListener;\n  self.triggers.forEach((btn) => action(btn, mouseclickEvent, offcanvasTriggerHandler));\n}\n\n/**\n * Toggles on/off the listeners of the events that close the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n * @param {boolean=} add when *true* listeners are added\n */\nfunction toggleOffCanvasDismiss(self, add) {\n  const action = add ? addListener : removeListener;\n  const doc = getDocument(self.element);\n  action(doc, keydownEvent, offcanvasKeyDismissHandler);\n  action(doc, mouseclickEvent, offcanvasDismissHandler);\n}\n\n/**\n * Executes before showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasShow(self) {\n  const { element, options } = self;\n\n  if (!options.scroll) {\n    setOffCanvasScrollbar(self);\n    setElementStyle(getDocumentBody(element), { overflow: 'hidden' });\n  }\n\n  addClass(element, offcanvasTogglingClass);\n  addClass(element, showClass);\n  setElementStyle(element, { visibility: 'visible' });\n\n  emulateTransitionEnd(element, () => showOffcanvasComplete(self));\n}\n\n/**\n * Executes before hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction beforeOffcanvasHide(self) {\n  const { element, options } = self;\n  const currentOpen = getCurrentOpen(element);\n\n  // @ts-ignore\n  element.blur();\n\n  if (!currentOpen && options.backdrop && hasClass(overlay, showClass)) {\n    hideOverlay();\n    emulateTransitionEnd(overlay, () => hideOffcanvasComplete(self));\n  } else hideOffcanvasComplete(self);\n}\n\n// OFFCANVAS EVENT HANDLERS\n// ========================\n/**\n * Handles the `click` event listeners.\n *\n * @this {HTMLElement | Element}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasTriggerHandler(e) {\n  const trigger = closest(this, offcanvasToggleSelector);\n  const element = trigger && getTargetElement(trigger);\n  const self = element && getOffcanvasInstance(element);\n\n  if (self) {\n    self.relatedTarget = trigger;\n    self.toggle();\n    if (trigger && trigger.tagName === 'A') {\n      e.preventDefault();\n    }\n  }\n}\n\n/**\n * Handles the event listeners that close the offcanvas.\n *\n * @this {Document}\n * @param {MouseEvent} e the `Event` object\n */\nfunction offcanvasDismissHandler(e) {\n  const element = querySelector(offcanvasActiveSelector, this);\n  if (!element) return;\n\n  const offCanvasDismiss = querySelector(offcanvasDismissSelector, element);\n  const self = getOffcanvasInstance(element);\n\n  if (!self) return;\n\n  const { options, triggers } = self;\n  const { target } = e;\n  // @ts-ignore -- `EventTarget` is `HTMLElement`\n  const trigger = closest(target, offcanvasToggleSelector);\n  const selection = getDocument(element).getSelection();\n\n  if (!(selection && selection.toString().length)\n    // @ts-ignore\n    && ((!element.contains(target) && options.backdrop\n    && (!trigger || (trigger && !triggers.includes(trigger))))\n    // @ts-ignore\n    || (offCanvasDismiss && offCanvasDismiss.contains(target)))) {\n    // @ts-ignore\n    self.relatedTarget = offCanvasDismiss && offCanvasDismiss.contains(target)\n      ? offCanvasDismiss : null;\n    self.hide();\n  }\n  if (trigger && trigger.tagName === 'A') e.preventDefault();\n}\n\n/**\n * Handles the `keydown` event listener for offcanvas\n * to hide it when user type the `ESC` key.\n *\n * @param {KeyboardEvent} e the `Event` object\n * @this {Document}\n */\nfunction offcanvasKeyDismissHandler({ code }) {\n  const element = querySelector(offcanvasActiveSelector, this);\n  if (!element) return;\n\n  const self = getOffcanvasInstance(element);\n\n  if (self && self.options.keyboard && code === keyEscape) {\n    self.relatedTarget = null;\n    self.hide();\n  }\n}\n\n/**\n * Handles the `transitionend` when showing the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction showOffcanvasComplete(self) {\n  const { element } = self;\n  removeClass(element, offcanvasTogglingClass);\n\n  removeAttribute(element, ariaHidden);\n  setAttribute(element, ariaModal, 'true');\n  setAttribute(element, 'role', 'dialog');\n\n  dispatchEvent(element, shownOffcanvasEvent);\n\n  toggleOffCanvasDismiss(self, true);\n  focus(element);\n}\n\n/**\n * Handles the `transitionend` when hiding the offcanvas.\n *\n * @param {Offcanvas} self the `Offcanvas` instance\n */\nfunction hideOffcanvasComplete(self) {\n  const { element, triggers } = self;\n\n  setAttribute(element, ariaHidden, 'true');\n  removeAttribute(element, ariaModal);\n  removeAttribute(element, 'role');\n  setElementStyle(element, { visibility: '' });\n\n  const visibleTrigger = showOffcanvasEvent.relatedTarget || triggers.find((x) => isVisible(x));\n  if (visibleTrigger) focus(visibleTrigger);\n\n  removeOverlay(element);\n\n  dispatchEvent(element, hiddenOffcanvasEvent);\n  removeClass(element, offcanvasTogglingClass);\n\n  // must check for open instances\n  if (!getCurrentOpen(element)) {\n    toggleOffCanvasDismiss(self);\n  }\n}\n\n// OFFCANVAS DEFINITION\n// ====================\n/** Returns a new `Offcanvas` instance. */\nclass Offcanvas extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target usually an `.offcanvas` element\n   * @param {BSN.Options.Offcanvas=} config instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    const self = this;\n\n    // instance element\n    const { element } = self;\n\n    // all the triggering buttons\n    /** @type {(HTMLElement | Element)[]} */\n    self.triggers = [...querySelectorAll(offcanvasToggleSelector)]\n      .filter((btn) => getTargetElement(btn) === element);\n\n    // additional instance property\n    /** @type {HTMLBodyElement | HTMLElement | Element} */\n    // @ts-ignore\n    self.container = getElementContainer(element);\n    /** @type {(HTMLElement | Element)?} */\n    self.relatedTarget = null;\n\n    // attach event listeners\n    toggleOffcanvasEvents(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return offcanvasComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return offcanvasDefaults; }\n  /* eslint-enable */\n\n  // OFFCANVAS PUBLIC METHODS\n  // ========================\n  /** Shows or hides the offcanvas from the user. */\n  toggle() {\n    const self = this;\n    if (hasClass(self.element, showClass)) self.hide();\n    else self.show();\n  }\n\n  /** Shows the offcanvas to the user. */\n  show() {\n    const self = this;\n    const {\n      element, options, container, relatedTarget,\n    } = self;\n    let overlayDelay = 0;\n\n    if (hasClass(element, showClass)) return;\n\n    showOffcanvasEvent.relatedTarget = relatedTarget;\n    shownOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, showOffcanvasEvent);\n    if (showOffcanvasEvent.defaultPrevented) return;\n\n    // we elegantly hide any opened modal/offcanvas\n    const currentOpen = getCurrentOpen(element);\n    if (currentOpen && currentOpen !== element) {\n      const this1 = getOffcanvasInstance(currentOpen);\n      const that1 = this1 || getInstance(currentOpen, 'Modal');\n      that1.hide();\n    }\n\n    if (options.backdrop) {\n      if (!container.contains(overlay)) {\n        appendOverlay(container, true);\n      } else {\n        toggleOverlayType();\n      }\n\n      overlayDelay = getElementTransitionDuration(overlay);\n      showOverlay();\n\n      setTimeout(() => beforeOffcanvasShow(self), overlayDelay);\n    } else {\n      beforeOffcanvasShow(self);\n      if (currentOpen && hasClass(overlay, showClass)) {\n        hideOverlay();\n      }\n    }\n  }\n\n  /**\n   * Hides the offcanvas from the user.\n   * @param {boolean=} force when `true` it will skip animation\n   */\n  hide(force) {\n    const self = this;\n    const { element, relatedTarget } = self;\n\n    if (!hasClass(element, showClass)) return;\n\n    hideOffcanvasEvent.relatedTarget = relatedTarget;\n    hiddenOffcanvasEvent.relatedTarget = relatedTarget;\n    dispatchEvent(element, hideOffcanvasEvent);\n    if (hideOffcanvasEvent.defaultPrevented) return;\n\n    addClass(element, offcanvasTogglingClass);\n    removeClass(element, showClass);\n\n    if (!force) {\n      emulateTransitionEnd(element, () => beforeOffcanvasHide(self));\n    } else beforeOffcanvasHide(self);\n  }\n\n  /** Removes the `Offcanvas` from the target element. */\n  dispose() {\n    const self = this;\n    self.hide(true);\n    toggleOffcanvasEvents(self);\n    super.dispose();\n  }\n}\n\nObjectAssign(Offcanvas, {\n  selector: offcanvasSelector,\n  init: offcanvasInitCallback,\n  getInstance: getOffcanvasInstance,\n});\n\n/** @type {string} */\nconst popoverString = 'popover';\n\n/** @type {string} */\nconst popoverComponent = 'Popover';\n\n/** @type {string} */\nconst tooltipString = 'tooltip';\n\n/**\n * Returns a template for Popover / Tooltip.\n *\n * @param {string} tipType the expected markup type\n * @returns {string} the template markup\n */\nfunction getTipTemplate(tipType) {\n  const isTooltip = tipType === tooltipString;\n  const bodyClass = isTooltip ? `${tipType}-inner` : `${tipType}-body`;\n  const header = !isTooltip ? `<h3 class=\"${tipType}-header\"></h3>` : '';\n  const arrow = `<div class=\"${tipType}-arrow\"></div>`;\n  const body = `<div class=\"${bodyClass}\"></div>`;\n  return `<div class=\"${tipType}\" role=\"${tooltipString}\">${header + arrow + body}</div>`;\n}\n\n/**\n * Checks if an element is an `<svg>` (or any type of SVG element),\n * `<img>` or `<video>`.\n *\n * *Tooltip* / *Popover* works different with media elements.\n * @param {any} element the target element\n * @returns {boolean} the query result\n */\nconst isMedia = (element) => element\n  && [SVGElement, HTMLImageElement, HTMLVideoElement]\n    .some((mediaType) => element instanceof mediaType);\n\n/**\n * Returns an `{x,y}` object with the target\n * `HTMLElement` / `Node` scroll position.\n *\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Element | Window} element target node / element\n * @returns {{x: number, y: number}} the scroll tuple\n */\nfunction getNodeScroll(element) {\n  const isWin = 'scrollX' in element;\n  const x = isWin ? element.scrollX : element.scrollLeft;\n  const y = isWin ? element.scrollY : element.scrollTop;\n\n  return { x, y };\n}\n\n/**\n * Checks if a target `HTMLElement` is affected by scale.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement} element target\n * @returns {boolean} the query result\n */\nfunction isScaledElement(element) {\n  const { width, height } = getBoundingClientRect(element);\n  const { offsetWidth, offsetHeight } = element;\n  return Math.round(width) !== offsetWidth\n    || Math.round(height) !== offsetHeight;\n}\n\n/**\n * Returns the rect relative to an offset parent.\n * @see https://github.com/floating-ui/floating-ui\n *\n * @param {HTMLElement | Element} element target\n * @param {HTMLElement | Element | Window} offsetParent the container / offset parent\n * @param {{x: number, y: number}} scroll\n * @returns {SHORTER.OffsetRect}\n */\nfunction getRectRelativeToOffsetParent(element, offsetParent, scroll) {\n  const isParentAnElement = offsetParent instanceof HTMLElement;\n  const rect = getBoundingClientRect(element, isParentAnElement && isScaledElement(offsetParent));\n  const offsets = { x: 0, y: 0 };\n\n  if (isParentAnElement) {\n    const offsetRect = getBoundingClientRect(offsetParent, true);\n    offsets.x = offsetRect.x + offsetParent.clientLeft;\n    offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n\n  return {\n    x: rect.left + scroll.x - offsets.x,\n    y: rect.top + scroll.y - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/** @type {Record<string, string>} */\nvar tipClassPositions = {\n  top: 'top',\n  bottom: 'bottom',\n  left: 'start',\n  right: 'end',\n};\n\n/**\n * Style popovers and tooltips.\n * @param {BSN.Tooltip | BSN.Popover} self the `Popover` / `Tooltip` instance\n * @param {PointerEvent=} e event object\n */\nfunction styleTip(self, e) {\n  const tipClasses = /\\b(top|bottom|start|end)+/;\n  const {\n    element, tooltip, options, arrow, offsetParent,\n  } = self;\n  const tipPositions = { ...tipClassPositions };\n\n  // reset tooltip style (top: 0, left: 0 works best)\n  setElementStyle(tooltip, { top: '0px', left: '0px', right: '' });\n  // @ts-ignore\n  const isPopover = self.name === popoverComponent;\n  const tipWidth = tooltip.offsetWidth;\n  const tipHeight = tooltip.offsetHeight;\n  const RTL = isRTL(element);\n  if (RTL) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n  const documentElement = getDocumentElement(element);\n  const windowWidth = documentElement.clientWidth;\n  const windowHeight = documentElement.clientHeight;\n  const { container } = options;\n  let { placement } = options;\n  const {\n    left: parentLeft, right: parentRight, top: parentTop,\n  } = getBoundingClientRect(container, true);\n  const parentWidth = container.clientWidth;\n  const scrollbarWidth = Math.abs(parentWidth - container.offsetWidth);\n  const parentPosition = getElementStyle(container, 'position');\n  // const absoluteParent = parentPosition === 'absolute';\n  const fixedParent = parentPosition === 'fixed';\n  const staticParent = parentPosition === 'static';\n  const stickyParent = parentPosition === 'sticky';\n  const isSticky = stickyParent && parentTop === parseFloat(getElementStyle(container, 'top'));\n  // const absoluteTarget = getElementStyle(element, 'position') === 'absolute';\n  // const stickyFixedParent = ['sticky', 'fixed'].includes(parentPosition);\n  const leftBoundry = RTL && fixedParent ? scrollbarWidth : 0;\n  const rightBoundry = fixedParent ? parentWidth + parentLeft + (RTL ? scrollbarWidth : 0)\n    : parentWidth + parentLeft + (windowWidth - parentRight) - 1;\n  const {\n    width: elemWidth,\n    height: elemHeight,\n    left: elemRectLeft,\n    right: elemRectRight,\n    top: elemRectTop,\n  } = getBoundingClientRect(element, true);\n\n  const scroll = getNodeScroll(offsetParent);\n  const { x, y } = getRectRelativeToOffsetParent(element, offsetParent, scroll);\n  // reset arrow style\n  setElementStyle(arrow, { top: '', left: '', right: '' });\n  let topPosition;\n  let leftPosition;\n  let rightPosition;\n  let arrowTop;\n  let arrowLeft;\n  let arrowRight;\n\n  const arrowWidth = arrow.offsetWidth || 0;\n  const arrowHeight = arrow.offsetHeight || 0;\n  const arrowAdjust = arrowWidth / 2;\n\n  // check placement\n  let topExceed = elemRectTop - tipHeight - arrowHeight < 0;\n  let bottomExceed = elemRectTop + tipHeight + elemHeight\n    + arrowHeight >= windowHeight;\n  let leftExceed = elemRectLeft - tipWidth - arrowWidth < leftBoundry;\n  let rightExceed = elemRectLeft + tipWidth + elemWidth\n    + arrowWidth >= rightBoundry;\n\n  const horizontal = ['left', 'right'];\n  const vertical = ['top', 'bottom'];\n  topExceed = horizontal.includes(placement)\n    ? elemRectTop + elemHeight / 2 - tipHeight / 2 - arrowHeight < 0\n    : topExceed;\n  bottomExceed = horizontal.includes(placement)\n    ? elemRectTop + tipHeight / 2 + elemHeight / 2 + arrowHeight >= windowHeight\n    : bottomExceed;\n  leftExceed = vertical.includes(placement)\n    ? elemRectLeft + elemWidth / 2 - tipWidth / 2 < leftBoundry\n    : leftExceed;\n  rightExceed = vertical.includes(placement)\n    ? elemRectLeft + tipWidth / 2 + elemWidth / 2 >= rightBoundry\n    : rightExceed;\n\n  // recompute placement\n  // first, when both left and right limits are exceeded, we fall back to top|bottom\n  placement = (horizontal.includes(placement)) && leftExceed && rightExceed ? 'top' : placement;\n  placement = placement === 'top' && topExceed ? 'bottom' : placement;\n  placement = placement === 'bottom' && bottomExceed ? 'top' : placement;\n  placement = placement === 'left' && leftExceed ? 'right' : placement;\n  placement = placement === 'right' && rightExceed ? 'left' : placement;\n\n  // update tooltip/popover class\n  if (!tooltip.className.includes(placement)) {\n    tooltip.className = tooltip.className.replace(tipClasses, tipPositions[placement]);\n  }\n\n  // compute tooltip / popover coordinates\n  if (horizontal.includes(placement)) { // secondary|side positions\n    if (placement === 'left') { // LEFT\n      leftPosition = x - tipWidth - (isPopover ? arrowWidth : 0);\n    } else { // RIGHT\n      leftPosition = x + elemWidth + (isPopover ? arrowWidth : 0);\n    }\n\n    // adjust top and arrow\n    if (topExceed) {\n      topPosition = y;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = elemHeight / 2 - arrowWidth;\n    } else if (bottomExceed) {\n      topPosition = y - tipHeight + elemHeight;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight - elemHeight / 2 - arrowWidth;\n    } else {\n      topPosition = y - tipHeight / 2 + elemHeight / 2;\n      topPosition += (isSticky ? -parentTop - scroll.y : 0);\n\n      arrowTop = tipHeight / 2 - arrowHeight / 2;\n    }\n  } else if (vertical.includes(placement)) {\n    if (e && isMedia(element)) {\n      let eX = 0;\n      let eY = 0;\n      if (staticParent) {\n        eX = e.pageX;\n        eY = e.pageY;\n      } else { // fixedParent | stickyParent\n        eX = e.clientX - parentLeft + (fixedParent ? scroll.x : 0);\n        eY = e.clientY - parentTop + (fixedParent ? scroll.y : 0);\n      }\n\n      // some weird RTL bug\n      eX -= RTL && fixedParent && scrollbarWidth ? scrollbarWidth : 0;\n\n      if (placement === 'top') {\n        topPosition = eY - tipHeight - arrowWidth;\n      } else {\n        topPosition = eY + arrowWidth;\n      }\n\n      // adjust (left | right) and also the arrow\n      if (e.clientX - tipWidth / 2 < leftBoundry) {\n        leftPosition = 0;\n        arrowLeft = eX - arrowAdjust;\n      } else if (e.clientX + tipWidth / 2 > rightBoundry) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = rightBoundry - eX - arrowAdjust;\n        arrowRight -= fixedParent ? parentLeft + (RTL ? scrollbarWidth : 0) : 0;\n\n      // normal top/bottom\n      } else {\n        leftPosition = eX - tipWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    } else {\n      if (placement === 'top') {\n        topPosition = y - tipHeight - (isPopover ? arrowHeight : 0);\n      } else { // BOTTOM\n        topPosition = y + elemHeight + (isPopover ? arrowHeight : 0);\n      }\n\n      // adjust left | right and also the arrow\n      if (leftExceed) {\n        leftPosition = 0;\n        arrowLeft = x + elemWidth / 2 - arrowAdjust;\n      } else if (rightExceed) {\n        leftPosition = 'auto';\n        rightPosition = 0;\n        arrowRight = elemWidth / 2 + rightBoundry - elemRectRight - arrowAdjust;\n      } else {\n        leftPosition = x - tipWidth / 2 + elemWidth / 2;\n        arrowLeft = tipWidth / 2 - arrowAdjust;\n      }\n    }\n  }\n\n  // apply style to tooltip/popover\n  setElementStyle(tooltip, {\n    top: `${topPosition}px`,\n    left: leftPosition === 'auto' ? leftPosition : `${leftPosition}px`,\n    right: rightPosition !== undefined ? `${rightPosition}px` : '',\n  });\n\n  // update arrow placement\n  if (arrow instanceof HTMLElement) {\n    if (arrowTop !== undefined) {\n      arrow.style.top = `${arrowTop}px`;\n    }\n    if (arrowLeft !== undefined) {\n      arrow.style.left = `${arrowLeft}px`;\n    } else if (arrowRight !== undefined) {\n      arrow.style.right = `${arrowRight}px`;\n    }\n  }\n}\n\nconst tooltipDefaults = {\n  /** @type {string} */\n  template: getTipTemplate(tooltipString),\n  /** @type {string?} */\n  title: null, // string\n  /** @type {string?} */\n  customClass: null, // string | null\n  /** @type {string} */\n  trigger: 'hover focus',\n  /** @type {string?} */\n  placement: 'top', // string\n  /** @type {((c:string)=>string)?} */\n  sanitizeFn: null, // function\n  /** @type {boolean} */\n  animation: true, // bool\n  /** @type {number} */\n  delay: 200, // number\n  /** @type {(HTMLElement | Element)?} */\n  container: null,\n};\n\n/**\n * A global namespace for aria-describedby.\n * @type {string}\n */\nconst ariaDescribedBy = 'aria-describedby';\n\n/**\n * A global namespace for `mousedown` event.\n * @type {string}\n */\nconst mousedownEvent = 'mousedown';\n\n/**\n * A global namespace for `mousemove` event.\n * @type {string}\n */\nconst mousemoveEvent = 'mousemove';\n\n/**\n * A global namespace for `focusin` event.\n * @type {string}\n */\nconst focusinEvent = 'focusin';\n\n/**\n * A global namespace for `focusout` event.\n * @type {string}\n */\nconst focusoutEvent = 'focusout';\n\n/**\n * A global namespace for `hover` event.\n * @type {string}\n */\nconst mousehoverEvent = 'hover';\n\nlet elementUID = 0;\nlet elementMapUID = 0;\nconst elementIDMap = new Map();\n\n/**\n * Returns a unique identifier for popover, tooltip, scrollspy.\n *\n * @param {HTMLElement | Element} element target element\n * @param {string=} key predefined key\n * @returns {number} an existing or new unique ID\n */\nfunction getUID(element, key) {\n  let result = key ? elementUID : elementMapUID;\n\n  if (key) {\n    const elID = getUID(element);\n    const elMap = elementIDMap.get(elID) || new Map();\n    if (!elementIDMap.has(elID)) {\n      elementIDMap.set(elID, elMap);\n    }\n    if (!elMap.has(key)) {\n      elMap.set(key, result);\n      elementUID += 1;\n    } else result = elMap.get(key);\n  } else {\n    const elkey = element.id || element;\n\n    if (!elementIDMap.has(elkey)) {\n      elementIDMap.set(elkey, result);\n      elementMapUID += 1;\n    } else result = elementIDMap.get(elkey);\n  }\n  return result;\n}\n\n// @ts-ignore\nconst { userAgentData: uaDATA } = navigator;\n\n/**\n * A global namespace for `userAgentData` object.\n */\nconst userAgentData = uaDATA;\n\nconst { userAgent: userAgentString } = navigator;\n\n/**\n * A global namespace for `navigator.userAgent` string.\n */\nconst userAgent = userAgentString;\n\nconst appleBrands = /(iPhone|iPod|iPad)/;\n\n/**\n * A global `boolean` for Apple browsers.\n * @type {boolean}\n */\nconst isApple = !userAgentData ? appleBrands.test(userAgent)\n  : userAgentData.brands.some((/** @type {Record<string, any>} */x) => appleBrands.test(x.brand));\n\n/**\n * Global namespace for `data-bs-title` attribute.\n */\nconst dataOriginalTitle = 'data-original-title';\n\n/** @type {string} */\nconst tooltipComponent = 'Tooltip';\n\n/**\n * Append an existing `Element` to Popover / Tooltip component or HTML\n * markup string to be parsed & sanitized to be used as popover / tooltip content.\n *\n * @param {HTMLElement | Element} element target\n * @param {HTMLElement | Element | string} content the `Element` to append / string\n * @param {ReturnType<any>} sanitizeFn a function to sanitize string content\n */\nfunction setHtml(element, content, sanitizeFn) {\n  if (typeof content === 'string' && !content.length) return;\n\n  if (typeof content === 'string') {\n    let dirty = content.trim(); // fixing #233\n    if (typeof sanitizeFn === 'function') dirty = sanitizeFn(dirty);\n\n    const domParser = new DOMParser();\n    const tempDocument = domParser.parseFromString(dirty, 'text/html');\n    const { body } = tempDocument;\n    const method = body.children.length ? 'innerHTML' : 'innerText';\n    // @ts-ignore\n    element[method] = body[method];\n  } else if (content instanceof HTMLElement) {\n    element.append(content);\n  }\n}\n\n/**\n * Creates a new tooltip / popover.\n *\n * @param {BSN.Popover | BSN.Tooltip} self the `Popover` instance\n */\nfunction createTip(self) {\n  const { id, element, options } = self;\n  const {\n    animation, customClass, sanitizeFn, placement, dismissible,\n  } = options;\n  let { title, content } = options;\n  const isTooltip = self.name === tooltipComponent;\n  const tipString = isTooltip ? tooltipString : popoverString;\n  const { template, btnClose } = options;\n  const tipPositions = { ...tipClassPositions };\n\n  if (isRTL(element)) {\n    tipPositions.left = 'end';\n    tipPositions.right = 'start';\n  }\n\n  // set initial popover class\n  const placementClass = `bs-${tipString}-${tipPositions[placement]}`;\n\n  // load template\n  /** @type {(HTMLElement | Element)?} */\n  let popoverTemplate;\n  if ([Element, HTMLElement].some((x) => template instanceof x)) {\n    popoverTemplate = template;\n  } else {\n    const htmlMarkup = getDocument(element).createElement('div');\n    setHtml(htmlMarkup, template, sanitizeFn);\n    popoverTemplate = htmlMarkup.firstElementChild;\n  }\n\n  // set popover markup\n  self.tooltip = popoverTemplate && popoverTemplate.cloneNode(true);\n\n  const { tooltip } = self;\n\n  // set id and role attributes\n  setAttribute(tooltip, 'id', id);\n  setAttribute(tooltip, 'role', tooltipString);\n\n  const bodyClass = isTooltip ? `${tooltipString}-inner` : `${popoverString}-body`;\n  const tooltipHeader = isTooltip ? null : querySelector(`.${popoverString}-header`, tooltip);\n  const tooltipBody = querySelector(`.${bodyClass}`, tooltip);\n\n  // set arrow and enable access for styleTip\n  self.arrow = querySelector(`.${tipString}-arrow`, tooltip);\n\n  // set dismissible button\n  if (dismissible) {\n    if (title) {\n      if (title instanceof HTMLElement) setHtml(title, btnClose, sanitizeFn);\n      else title += btnClose;\n    } else {\n      if (tooltipHeader) tooltipHeader.remove();\n      if (content instanceof HTMLElement) setHtml(content, btnClose, sanitizeFn);\n      else content += btnClose;\n    }\n  }\n\n  // fill the template with content from options / data attributes\n  // also sanitize title && content\n  if (!isTooltip) {\n    if (title && tooltipHeader) setHtml(tooltipHeader, title, sanitizeFn);\n    if (content && tooltipBody) setHtml(tooltipBody, content, sanitizeFn);\n    // @ts-ignore -- set btn\n    self.btn = querySelector('.btn-close', tooltip);\n  } else if (title && tooltipBody) setHtml(tooltipBody, title, sanitizeFn);\n\n  // set popover animation and placement\n  if (!hasClass(tooltip, tipString)) addClass(tooltip, tipString);\n  if (animation && !hasClass(tooltip, fadeClass)) addClass(tooltip, fadeClass);\n  if (customClass && !hasClass(tooltip, customClass)) {\n    addClass(tooltip, customClass);\n  }\n  if (!hasClass(tooltip, placementClass)) addClass(tooltip, placementClass);\n}\n\n/**\n * @param {(HTMLElement | Element)?} tip target\n * @param {HTMLElement | ParentNode} container parent container\n * @returns {boolean}\n */\nfunction isVisibleTip(tip, container) {\n  return tip instanceof HTMLElement && container.contains(tip);\n}\n\n/* Native JavaScript for Bootstrap 5 | Tooltip\n---------------------------------------------- */\n\n// TOOLTIP PRIVATE GC\n// ==================\nconst tooltipSelector = `[${dataBsToggle}=\"${tooltipString}\"],[data-tip=\"${tooltipString}\"]`;\nconst titleAttr = 'title';\n\n/**\n * Static method which returns an existing `Tooltip` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tooltip>}\n */\nlet getTooltipInstance = (element) => getInstance(element, tooltipComponent);\n\n/**\n * A `Tooltip` initialization callback.\n * @type {BSN.InitCallback<Tooltip>}\n */\nconst tooltipInitCallback = (element) => new Tooltip(element);\n\n// TOOLTIP PRIVATE METHODS\n// =======================\n/**\n * Removes the tooltip from the DOM.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction removeTooltip(self) {\n  const { element, tooltip } = self;\n  removeAttribute(element, ariaDescribedBy);\n  tooltip.remove();\n}\n\n/**\n * Executes after the instance has been disposed.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction disposeTooltipComplete(self) {\n  const { element } = self;\n  toggleTooltipHandlers(self);\n\n  if (element.hasAttribute(dataOriginalTitle) && self.name === tooltipString) {\n    toggleTooltipTitle(self);\n  }\n}\n\n/**\n * Toggles on/off the special `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipAction(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element } = self;\n\n  action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n\n  if (!isMedia(element)) {\n    [scrollEvent, resizeEvent].forEach((ev) => {\n      // @ts-ignore\n      action(getWindow(element), ev, self.update, passiveHandler);\n    });\n  }\n}\n\n/**\n * Executes after the tooltip was shown to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipShownAction(self) {\n  const { element } = self;\n  const shownTooltipEvent = OriginalEvent(`shown.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self, true);\n  dispatchEvent(element, shownTooltipEvent);\n  Timer.clear(element, 'in');\n}\n\n/**\n * Executes after the tooltip was hidden to the user.\n *\n * @param {Tooltip} self the `Tooltip` instance\n */\nfunction tooltipHiddenAction(self) {\n  const { element } = self;\n  const hiddenTooltipEvent = OriginalEvent(`hidden.bs.${toLowerCase(self.name)}`);\n\n  toggleTooltipAction(self);\n  removeTooltip(self);\n  dispatchEvent(element, hiddenTooltipEvent);\n  Timer.clear(element, 'out');\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // @ts-ignore -- btn is only for dismissible popover\n  const { element, options, btn } = self;\n  const { trigger, dismissible } = options;\n\n  if (trigger.includes('manual')) return;\n\n  self.enabled = !!add;\n\n  /** @type {string[]} */\n  const triggerOptions = trigger.split(' ');\n  const elemIsMedia = isMedia(element);\n\n  if (elemIsMedia) {\n    action(element, mousemoveEvent, self.update, passiveHandler);\n  }\n\n  triggerOptions.forEach((tr) => {\n    if (elemIsMedia || tr === mousehoverEvent) {\n      action(element, mousedownEvent, self.show);\n      action(element, mouseenterEvent, self.show);\n\n      if (dismissible && btn) {\n        action(btn, mouseclickEvent, self.hide);\n      } else {\n        action(element, mouseleaveEvent, self.hide);\n        action(getDocument(element), touchstartEvent, self.handleTouch, passiveHandler);\n      }\n    } else if (tr === mouseclickEvent) {\n      action(element, tr, (!dismissible ? self.toggle : self.show));\n    } else if (tr === focusEvent) {\n      action(element, focusinEvent, self.show);\n      if (!dismissible) action(element, focusoutEvent, self.hide);\n      if (isApple) action(element, mouseclickEvent, () => focus(element));\n    }\n  });\n}\n\n/**\n * Toggles on/off the `Tooltip` event listeners that hide/update the tooltip.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {boolean=} add when `true`, event listeners are added\n */\nfunction toggleTooltipOpenHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, options, offsetParent } = self;\n  const { container } = options;\n  const { offsetHeight, scrollHeight } = container;\n  const parentModal = closest(element, `.${modalString}`);\n  const parentOffcanvas = closest(element, `.${offcanvasString}`);\n\n  if (!isMedia(element)) {\n    const win = getWindow(element);\n    const overflow = offsetHeight !== scrollHeight;\n    const scrollTarget = overflow || offsetParent !== win ? container : win;\n    // @ts-ignore\n    action(win, resizeEvent, self.update, passiveHandler);\n    action(scrollTarget, scrollEvent, self.update, passiveHandler);\n  }\n\n  // dismiss tooltips inside modal / offcanvas\n  if (parentModal) action(parentModal, `hide.bs.${modalString}`, self.hide);\n  if (parentOffcanvas) action(parentOffcanvas, `hide.bs.${offcanvasString}`, self.hide);\n}\n\n/**\n * Toggles the `title` and `data-original-title` attributes.\n *\n * @param {Tooltip} self the `Tooltip` instance\n * @param {string=} content when `true`, event listeners are added\n */\nfunction toggleTooltipTitle(self, content) {\n  // [0 - add, 1 - remove] | [0 - remove, 1 - add]\n  const titleAtt = [dataOriginalTitle, titleAttr];\n  const { element } = self;\n\n  setAttribute(element, titleAtt[content ? 0 : 1],\n    // @ts-ignore\n    (content || getAttribute(element, titleAtt[0])));\n  removeAttribute(element, titleAtt[content ? 1 : 0]);\n}\n\n// TOOLTIP DEFINITION\n// ==================\n/** Creates a new `Tooltip` instance. */\nclass Tooltip extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target the target element\n   * @param {BSN.Options.Tooltip=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n\n    // bind\n    const self = this;\n    const { element } = self;\n    const isTooltip = self.name === tooltipComponent;\n    const tipString = isTooltip ? tooltipString : popoverString;\n    const tipComponent = isTooltip ? tooltipComponent : popoverComponent;\n\n    getTooltipInstance = (elem) => getInstance(elem, tipComponent);\n\n    // additional properties\n    /** @type {any} */\n    self.tooltip = {};\n    if (!isTooltip) {\n      /** @type {any?} */\n      // @ts-ignore\n      self.btn = null;\n    }\n    /** @type {any} */\n    self.arrow = {};\n    /** @type {any} */\n    self.offsetParent = {};\n    /** @type {boolean} */\n    self.enabled = true;\n    /** @type {string} Set unique ID for `aria-describedby`. */\n    self.id = `${tipString}-${getUID(element, tipString)}`;\n\n    // instance options\n    const { options } = self;\n\n    // invalidate\n    if ((!options.title && isTooltip) || (!isTooltip && !options.content)) return;\n\n    const container = querySelector(options.container);\n    const idealContainer = getElementContainer(element);\n\n    // bypass container option when its position is static/relative\n    self.options.container = !container || (container\n      && ['static', 'relative'].includes(getElementStyle(container, 'position')))\n      ? idealContainer\n      : container || getDocumentBody(element);\n\n    // reset default options\n    tooltipDefaults[titleAttr] = null;\n\n    // all functions bind\n    self.handleTouch = self.handleTouch.bind(self);\n    self.update = self.update.bind(self);\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n    self.toggle = self.toggle.bind(self);\n\n    // set title attributes and add event listeners\n    if (element.hasAttribute(titleAttr) && isTooltip) {\n      toggleTooltipTitle(self, options.title);\n    }\n\n    // create tooltip here\n    createTip(self);\n\n    // attach events\n    toggleTooltipHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return tooltipComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return tooltipDefaults; }\n  /* eslint-enable */\n\n  // TOOLTIP PUBLIC METHODS\n  // ======================\n  /**\n   * Shows the tooltip.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip}\n   */\n  show(e) {\n    const self = this;\n    const {\n      options, tooltip, element, id,\n    } = self;\n    const { container, animation } = options;\n    const outTimer = Timer.get(element, 'out');\n\n    Timer.clear(element, 'out');\n\n    if (tooltip && !outTimer && !isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const showTooltipEvent = OriginalEvent(`show.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, showTooltipEvent);\n        if (showTooltipEvent.defaultPrevented) return;\n\n        // append to container\n        container.append(tooltip);\n        setAttribute(element, ariaDescribedBy, `#${id}`);\n        // set offsetParent\n        self.offsetParent = getElementContainer(tooltip, true);\n\n        self.update(e);\n        toggleTooltipOpenHandlers(self, true);\n\n        if (!hasClass(tooltip, showClass)) addClass(tooltip, showClass);\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipShownAction(self));\n        else tooltipShownAction(self);\n      }, 17, 'in');\n    }\n  }\n\n  /**\n   * Hides the tooltip.\n   *\n   * @this {Tooltip}\n   */\n  hide() {\n    const self = this;\n    const { options, tooltip, element } = self;\n    const { container, animation, delay } = options;\n\n    Timer.clear(element, 'in');\n\n    if (tooltip && isVisibleTip(tooltip, container)) {\n      Timer.set(element, () => {\n        const hideTooltipEvent = OriginalEvent(`hide.bs.${toLowerCase(self.name)}`);\n        dispatchEvent(element, hideTooltipEvent);\n\n        if (hideTooltipEvent.defaultPrevented) return;\n\n        // @ts-ignore\n        removeClass(tooltip, showClass);\n        toggleTooltipOpenHandlers(self);\n\n        if (animation) emulateTransitionEnd(tooltip, () => tooltipHiddenAction(self));\n        else tooltipHiddenAction(self);\n      }, delay + 17, 'out');\n    }\n  }\n\n  /**\n   * Updates the tooltip position.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the `Tooltip` instance\n   */\n  update(e) {\n    // @ts-ignore\n    styleTip(this, e);\n  }\n\n  /**\n   * Toggles the tooltip visibility.\n   *\n   * @param {Event=} e the `Event` object\n   * @this {Tooltip} the instance\n   */\n  toggle(e) {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (!isVisibleTip(tooltip, options.container)) self.show(e);\n    else self.hide();\n  }\n\n  /** Enables the tooltip. */\n  enable() {\n    const self = this;\n    const { enabled } = self;\n    if (!enabled) {\n      toggleTooltipHandlers(self, true);\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Disables the tooltip. */\n  disable() {\n    const self = this;\n    const {\n      element, tooltip, options, enabled,\n    } = self;\n    const { animation, container, delay } = options;\n    if (enabled) {\n      if (isVisibleTip(tooltip, container) && animation) {\n        self.hide();\n\n        Timer.set(element, () => {\n          toggleTooltipHandlers(self);\n          Timer.clear(element, tooltipString);\n        }, getElementTransitionDuration(tooltip) + delay + 17, tooltipString);\n      } else {\n        toggleTooltipHandlers(self);\n      }\n      self.enabled = !enabled;\n    }\n  }\n\n  /** Toggles the `disabled` property. */\n  toggleEnabled() {\n    const self = this;\n    if (!self.enabled) self.enable();\n    else self.disable();\n  }\n\n  /**\n   * Handles the `touchstart` event listener for `Tooltip`\n   * @this {Tooltip}\n   * @param {TouchEvent} e the `Event` object\n   */\n  handleTouch({ target }) {\n    const { tooltip, element } = this;\n\n    if (tooltip.contains(target) || target === element\n      // @ts-ignore\n      || (target && element.contains(target))) ; else {\n      this.hide();\n    }\n  }\n\n  /** Removes the `Tooltip` from the target element. */\n  dispose() {\n    const self = this;\n    const { tooltip, options } = self;\n\n    if (options.animation && isVisibleTip(tooltip, options.container)) {\n      options.delay = 0; // reset delay\n      self.hide();\n      emulateTransitionEnd(tooltip, () => disposeTooltipComplete(self));\n    } else {\n      disposeTooltipComplete(self);\n    }\n    super.dispose();\n  }\n}\n\nObjectAssign(Tooltip, {\n  selector: tooltipSelector,\n  init: tooltipInitCallback,\n  getInstance: getTooltipInstance,\n  styleTip,\n});\n\n/* Native JavaScript for Bootstrap 5 | Popover\n---------------------------------------------- */\n\n// POPOVER PRIVATE GC\n// ==================\nconst popoverSelector = `[${dataBsToggle}=\"${popoverString}\"],[data-tip=\"${popoverString}\"]`;\n\nconst popoverDefaults = {\n  ...tooltipDefaults,\n  /** @type {string} */\n  template: getTipTemplate(popoverString),\n  /** @type {string} */\n  btnClose: '<button class=\"btn-close\" aria-label=\"Close\"></button>',\n  /** @type {boolean} */\n  dismissible: false,\n  /** @type {string?} */\n  content: null,\n};\n\n// POPOVER DEFINITION\n// ==================\n/** Returns a new `Popover` instance. */\nclass Popover extends Tooltip {\n  /* eslint-disable -- we want to specify Popover Options */\n  /**\n   * @param {HTMLElement | Element | string} target the target element\n   * @param {BSN.Options.Popover=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n  }\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */ \n  get name() { return popoverComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return popoverDefaults; }\n  /* eslint-enable */\n\n  /* extend original `show()` */\n  show() {\n    super.show();\n    // @ts-ignore -- btn only exists within dismissible popover\n    const { options, btn } = this;\n    if (options.dismissible && btn) setTimeout(() => focus(btn), 17);\n  }\n}\n\n/**\n * Static method which returns an existing `Popover` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Popover>}\n */\nconst getPopoverInstance = (element) => getInstance(element, popoverComponent);\n\n/**\n * A `Popover` initialization callback.\n * @type {BSN.InitCallback<Popover>}\n */\nconst popoverInitCallback = (element) => new Popover(element);\n\nObjectAssign(Popover, {\n  selector: popoverSelector,\n  init: popoverInitCallback,\n  getInstance: getPopoverInstance,\n  styleTip,\n});\n\n/**\n * Shortcut for `HTMLElement.getElementsByTagName` method. Some `Node` elements\n * like `ShadowRoot` do not support `getElementsByTagName`.\n *\n * @param {string} selector the tag name\n * @param {(HTMLElement | Element | Document)=} parent optional Element to look into\n * @return {HTMLCollectionOf<HTMLElement | Element>} the 'HTMLCollection'\n */\nfunction getElementsByTagName(selector, parent) {\n  const lookUp = parent && parentNodes\n    .some((x) => parent instanceof x) ? parent : getDocument();\n  return lookUp.getElementsByTagName(selector);\n}\n\n/** @type {string} */\nconst scrollspyString = 'scrollspy';\n\n/** @type {string} */\nconst scrollspyComponent = 'ScrollSpy';\n\n/* Native JavaScript for Bootstrap 5 | ScrollSpy\n------------------------------------------------ */\n\n// console.log(typeof addEventListener)\n\n// SCROLLSPY PRIVATE GC\n// ====================\nconst scrollspySelector = '[data-bs-spy=\"scroll\"]';\n\nconst scrollspyDefaults = {\n  offset: 10,\n  target: null,\n};\n\n/**\n * Static method which returns an existing `ScrollSpy` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<ScrollSpy>}\n */\nconst getScrollSpyInstance = (element) => getInstance(element, scrollspyComponent);\n\n/**\n * A `ScrollSpy` initialization callback.\n * @type {BSN.InitCallback<ScrollSpy>}\n */\nconst scrollspyInitCallback = (element) => new ScrollSpy(element);\n\n// SCROLLSPY CUSTOM EVENT\n// ======================\nconst activateScrollSpy = OriginalEvent(`activate.bs.${scrollspyString}`);\n\n// SCROLLSPY PRIVATE METHODS\n// =========================\n/**\n * Update the state of all items.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n */\nfunction updateSpyTargets(self) {\n  const {\n    target, scrollTarget, options, itemsLength, scrollHeight, element,\n  } = self;\n  const { offset } = options;\n  const isWin = scrollTarget instanceof Window;\n\n  const links = target && getElementsByTagName('A', target);\n  const scrollHEIGHT = scrollTarget && getScrollHeight(scrollTarget);\n\n  // @ts-ignore\n  self.scrollTop = isWin ? scrollTarget.scrollY : scrollTarget.scrollTop;\n\n  // only update items/offsets once or with each mutation\n  if (links && (itemsLength !== links.length || scrollHEIGHT !== scrollHeight)) {\n    let href;\n    let targetItem;\n    let rect;\n\n    // reset arrays & update\n    self.items = [];\n    self.offsets = [];\n    self.scrollHeight = scrollHEIGHT;\n    self.maxScroll = self.scrollHeight - getOffsetHeight(self);\n\n    [...links].forEach((link) => {\n      href = getAttribute(link, 'href');\n      targetItem = href && href.charAt(0) === '#' && href.slice(-1) !== '#'\n        && querySelector(href, getDocument(element));\n\n      if (targetItem) {\n        self.items.push(link);\n        rect = getBoundingClientRect(targetItem);\n        // @ts-ignore\n        self.offsets.push((isWin ? rect.top + self.scrollTop : targetItem.offsetTop) - offset);\n      }\n    });\n    self.itemsLength = self.items.length;\n  }\n}\n\n/**\n * Returns the `scrollHeight` property of the scrolling element.\n * @param {HTMLElement | Element | Window | globalThis} scrollTarget the `ScrollSpy` instance\n * @return {number} `scrollTarget` height\n */\nfunction getScrollHeight(scrollTarget) {\n  return scrollTarget instanceof HTMLElement\n    ? scrollTarget.scrollHeight // @ts-ignore\n    : getDocumentElement(scrollTarget).scrollHeight;\n}\n\n/**\n * Returns the height property of the scrolling element.\n * @param {ScrollSpy} params the `ScrollSpy` instance\n * @returns {number}\n */\nfunction getOffsetHeight({ element, scrollTarget }) {\n  return (scrollTarget instanceof Window)\n    ? scrollTarget.innerHeight\n    : getBoundingClientRect(element).height;\n}\n\n/**\n * Clear all items of the target.\n * @param {HTMLElement | Element} target a single item\n */\nfunction clear(target) {\n  [...getElementsByTagName('A', target)].forEach((item) => {\n    if (hasClass(item, activeClass)) removeClass(item, activeClass);\n  });\n}\n\n/**\n * Activates a new item.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {HTMLElement | Element} item a single item\n */\nfunction activate(self, item) {\n  const { target, element } = self;\n  // @ts-ignore\n  clear(target);\n  // @ts-ignore\n  self.activeItem = item;\n  addClass(item, activeClass);\n\n  // activate all parents\n  const parents = [];\n  let parentItem = item;\n  while (parentItem !== getDocumentBody(element)) {\n    // @ts-ignore\n    parentItem = parentItem.parentElement;\n    if (hasClass(parentItem, 'nav') || hasClass(parentItem, 'dropdown-menu')) parents.push(parentItem);\n  }\n\n  parents.forEach((menuItem) => {\n    /** @type {(HTMLElement | Element)?} */\n    const parentLink = menuItem.previousElementSibling;\n\n    if (parentLink && !hasClass(parentLink, activeClass)) {\n      addClass(parentLink, activeClass);\n    }\n  });\n\n  // dispatch\n  activateScrollSpy.relatedTarget = item;\n  dispatchEvent(element, activateScrollSpy);\n}\n\n/**\n * Toggles on/off the component event listener.\n * @param {ScrollSpy} self the `ScrollSpy` instance\n * @param {boolean=} add when `true`, listener is added\n */\nfunction toggleSpyHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  // @ts-ignore\n  action(self.scrollTarget, scrollEvent, self.refresh, passiveHandler);\n}\n\n// SCROLLSPY DEFINITION\n// ====================\n/** Returns a new `ScrollSpy` instance. */\nclass ScrollSpy extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target the target element\n   * @param {BSN.Options.ScrollSpy=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n\n    // initialization element & options\n    const { element, options } = self;\n\n    // additional properties\n    /** @type {(HTMLElement | Element)?} */\n    self.target = querySelector(options.target, getDocument(element));\n\n    // invalidate\n    if (!self.target) return;\n\n    const win = getWindow(element);\n\n    // set initial state\n    /** @type {HTMLElement | Element | Window | globalThis} */\n    self.scrollTarget = element.clientHeight < element.scrollHeight ? element : win;\n    /** @type {number} */\n    self.scrollTop = 0;\n    /** @type {number} */\n    self.maxScroll = 0;\n    /** @type {number} */\n    self.scrollHeight = 0;\n    /** @type {(HTMLElement | Element)?} */\n    self.activeItem = null;\n    /** @type {(HTMLElement | Element)[]} */\n    self.items = [];\n    /** @type {number} */\n    self.itemsLength = 0;\n    /** @type {number[]} */\n    self.offsets = [];\n\n    // bind events\n    self.refresh = self.refresh.bind(self);\n\n    // add event handlers\n    toggleSpyHandlers(self, true);\n\n    self.refresh();\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */\n  get name() { return scrollspyComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */\n  get defaults() { return scrollspyDefaults; }\n  /* eslint-enable */\n\n  // SCROLLSPY PUBLIC METHODS\n  // ========================\n  /** Updates all items. */\n  refresh() {\n    const self = this;\n    const { target } = self;\n\n    // check if target is visible and invalidate\n    // @ts-ignore\n    if (target.offsetHeight === 0) return;\n\n    updateSpyTargets(self);\n\n    const {\n      scrollTop, maxScroll, itemsLength, items, activeItem,\n    } = self;\n\n    if (scrollTop >= maxScroll) {\n      const newActiveItem = items[itemsLength - 1];\n\n      if (activeItem !== newActiveItem) {\n        activate(self, newActiveItem);\n      }\n      return;\n    }\n\n    const { offsets } = self;\n\n    if (activeItem && scrollTop < offsets[0] && offsets[0] > 0) {\n      self.activeItem = null;\n      // @ts-ignore\n      clear(target);\n      return;\n    }\n\n    items.forEach((item, i) => {\n      if (activeItem !== item && scrollTop >= offsets[i]\n        && (typeof offsets[i + 1] === 'undefined' || scrollTop < offsets[i + 1])) {\n        activate(self, item);\n      }\n    });\n  }\n\n  /** Removes `ScrollSpy` from the target element. */\n  dispose() {\n    toggleSpyHandlers(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(ScrollSpy, {\n  selector: scrollspySelector,\n  init: scrollspyInitCallback,\n  getInstance: getScrollSpyInstance,\n});\n\n/**\n * A global namespace for aria-selected.\n * @type {string}\n */\nconst ariaSelected = 'aria-selected';\n\n/** @type {string} */\nconst tabString = 'tab';\n\n/** @type {string} */\nconst tabComponent = 'Tab';\n\n/* Native JavaScript for Bootstrap 5 | Tab\n------------------------------------------ */\n\n// TAB PRIVATE GC\n// ================\nconst tabSelector = `[${dataBsToggle}=\"${tabString}\"]`;\n\n/**\n * Static method which returns an existing `Tab` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Tab>}\n */\nconst getTabInstance = (element) => getInstance(element, tabComponent);\n\n/**\n * A `Tab` initialization callback.\n * @type {BSN.InitCallback<Tab>}\n */\nconst tabInitCallback = (element) => new Tab(element);\n\n// TAB CUSTOM EVENTS\n// =================\nconst showTabEvent = OriginalEvent(`show.bs.${tabString}`);\nconst shownTabEvent = OriginalEvent(`shown.bs.${tabString}`);\nconst hideTabEvent = OriginalEvent(`hide.bs.${tabString}`);\nconst hiddenTabEvent = OriginalEvent(`hidden.bs.${tabString}`);\n\n/**\n * Stores the current active tab and its content\n * for a given `.nav` element.\n * @type {Map<(HTMLElement | Element), any>}\n */\nconst tabPrivate = new Map();\n\n// TAB PRIVATE METHODS\n// ===================\n/**\n * Executes after tab transition has finished.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabEnd(self) {\n  const { tabContent, nav } = self;\n\n  if (tabContent && hasClass(tabContent, collapsingClass)) {\n    // @ts-ignore\n    tabContent.style.height = '';\n    removeClass(tabContent, collapsingClass);\n  }\n\n  if (nav) Timer.clear(nav);\n}\n\n/**\n * Executes before showing the tab content.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabShow(self) {\n  const {\n    element, tabContent, content: nextContent, nav,\n  } = self;\n  const { tab } = nav && tabPrivate.get(nav);\n\n  if (tabContent && hasClass(nextContent, fadeClass)) { // height animation\n    const { currentHeight, nextHeight } = tabPrivate.get(element);\n    if (currentHeight === nextHeight) {\n      triggerTabEnd(self);\n    } else {\n      setTimeout(() => { // enables height animation\n        // @ts-ignore\n        tabContent.style.height = `${nextHeight}px`; // height animation\n        reflow(tabContent);\n        emulateTransitionEnd(tabContent, () => triggerTabEnd(self));\n      }, 50);\n    }\n  } else if (nav) Timer.clear(nav);\n\n  shownTabEvent.relatedTarget = tab;\n  dispatchEvent(element, shownTabEvent);\n}\n\n/**\n * Executes before hiding the tab.\n * @param {Tab} self the `Tab` instance\n */\nfunction triggerTabHide(self) {\n  const {\n    element, content: nextContent, tabContent, nav,\n  } = self;\n  const { tab, content } = nav && tabPrivate.get(nav);\n  let currentHeight = 0;\n\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    [content, nextContent].forEach((c) => {\n      addClass(c, 'overflow-hidden');\n    });\n    currentHeight = content.scrollHeight || 0;\n  }\n\n  // update relatedTarget and dispatch event\n  showTabEvent.relatedTarget = tab;\n  hiddenTabEvent.relatedTarget = element;\n  dispatchEvent(element, showTabEvent);\n  if (showTabEvent.defaultPrevented) return;\n\n  addClass(nextContent, activeClass);\n  removeClass(content, activeClass);\n\n  if (tabContent && hasClass(nextContent, fadeClass)) {\n    const nextHeight = nextContent.scrollHeight;\n    tabPrivate.set(element, { currentHeight, nextHeight });\n\n    addClass(tabContent, collapsingClass);\n    // @ts-ignore -- height animation\n    tabContent.style.height = `${currentHeight}px`;\n    reflow(tabContent);\n    [content, nextContent].forEach((c) => {\n      removeClass(c, 'overflow-hidden');\n    });\n  }\n\n  if (nextContent && hasClass(nextContent, fadeClass)) {\n    setTimeout(() => {\n      addClass(nextContent, showClass);\n      emulateTransitionEnd(nextContent, () => {\n        triggerTabShow(self);\n      });\n    }, 1);\n  } else {\n    addClass(nextContent, showClass);\n    triggerTabShow(self);\n  }\n\n  dispatchEvent(tab, hiddenTabEvent);\n}\n\n/**\n * Returns the current active tab and its target content.\n * @param {Tab} self the `Tab` instance\n * @returns {Record<string, any>} the query result\n */\nfunction getActiveTab(self) {\n  const { nav } = self;\n\n  // @ts-ignore\n  const activeTabs = getElementsByClassName(activeClass, nav);\n  /** @type {(HTMLElement | Element)=} */\n  let tab;\n  if (activeTabs.length === 1\n    // @ts-ignore\n    && !dropdownMenuClasses.some((c) => hasClass(activeTabs[0].parentElement, c))) {\n    [tab] = activeTabs;\n  } else if (activeTabs.length > 1) {\n    tab = activeTabs[activeTabs.length - 1];\n  }\n  const content = tab ? getTargetElement(tab) : null;\n  // @ts-ignore\n  return { tab, content };\n}\n\n/**\n * Returns a parent dropdown.\n * @param {HTMLElement | Element} element the `Tab` element\n * @returns {(HTMLElement | Element)?} the parent dropdown\n */\nfunction getParentDropdown(element) {\n  const dropdown = closest(element, `.${dropdownMenuClasses.join(',.')}`);\n  return dropdown ? querySelector(`.${dropdownMenuClasses[0]}-toggle`, dropdown) : null;\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Tab} self the `Tab` instance\n * @param {boolean=} add when `true`, event listener is added\n */\nfunction toggleTabHandler(self, add) {\n  const action = add ? addListener : removeListener;\n  action(self.element, mouseclickEvent, tabClickHandler);\n}\n\n// TAB EVENT HANDLER\n// =================\n/**\n * Handles the `click` event listener.\n * @this {HTMLElement | Element}\n * @param {MouseEvent} e the `Event` object\n */\nfunction tabClickHandler(e) {\n  const self = getTabInstance(this);\n  if (!self) return;\n  e.preventDefault();\n\n  self.show();\n}\n\n// TAB DEFINITION\n// ==============\n/** Creates a new `Tab` instance. */\nclass Tab extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target the target element\n   */\n  constructor(target) {\n    super(target);\n    // bind\n    const self = this;\n\n    // initialization element\n    const { element } = self;\n    const content = getTargetElement(element);\n\n    // no point initializing a tab without a corresponding content\n    if (!content) return;\n\n    const nav = closest(element, '.nav');\n    const container = closest(content, '.tab-content');\n\n    /** @type {(HTMLElement | Element)?} */\n    self.nav = nav;\n    /** @type {HTMLElement | Element} */\n    self.content = content;\n    /** @type {(HTMLElement | Element)?} */\n    self.tabContent = container;\n\n    // event targets\n    /** @type {(HTMLElement | Element)?} */\n    self.dropdown = getParentDropdown(element);\n\n    // show first Tab instance of none is shown\n    // suggested on #432\n    const { tab } = getActiveTab(self);\n    if (nav && !tab) {\n      const firstTab = querySelector(tabSelector, nav);\n      const firstTabContent = firstTab && getTargetElement(firstTab);\n\n      if (firstTabContent) {\n        addClass(firstTab, activeClass);\n        addClass(firstTabContent, showClass);\n        addClass(firstTabContent, activeClass);\n        setAttribute(element, ariaSelected, 'true');\n      }\n    }\n\n    // add event listener\n    toggleTabHandler(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */  \n  get name() { return tabComponent; }\n  /* eslint-enable */\n\n  // TAB PUBLIC METHODS\n  // ==================\n  /** Shows the tab to the user. */\n  show() {\n    const self = this;\n    const { element, nav, dropdown } = self;\n\n    if (!(nav && Timer.get(nav)) && !hasClass(element, activeClass)) {\n      const { tab, content } = getActiveTab(self);\n\n      if (nav) tabPrivate.set(nav, { tab, content });\n\n      // update relatedTarget and dispatch\n      hideTabEvent.relatedTarget = element;\n\n      dispatchEvent(tab, hideTabEvent);\n      if (hideTabEvent.defaultPrevented) return;\n\n      addClass(element, activeClass);\n      setAttribute(element, ariaSelected, 'true');\n\n      const activeDropdown = getParentDropdown(tab);\n      if (activeDropdown && hasClass(activeDropdown, activeClass)) {\n        removeClass(activeDropdown, activeClass);\n      }\n\n      if (nav) {\n        Timer.set(nav, () => {\n          removeClass(tab, activeClass);\n          setAttribute(tab, ariaSelected, 'false');\n          if (dropdown && !hasClass(dropdown, activeClass)) addClass(dropdown, activeClass);\n        }, 1);\n      }\n\n      if (hasClass(content, fadeClass)) {\n        removeClass(content, showClass);\n        emulateTransitionEnd(content, () => triggerTabHide(self));\n      } else {\n        triggerTabHide(self);\n      }\n    }\n  }\n\n  /** Removes the `Tab` component from the target element. */\n  dispose() {\n    toggleTabHandler(this);\n    super.dispose();\n  }\n}\n\nObjectAssign(Tab, {\n  selector: tabSelector,\n  init: tabInitCallback,\n  getInstance: getTabInstance,\n});\n\n/** @type {string} */\nconst toastString = 'toast';\n\n/** @type {string} */\nconst toastComponent = 'Toast';\n\n/* Native JavaScript for Bootstrap 5 | Toast\n-------------------------------------------- */\n\n// TOAST PRIVATE GC\n// ================\nconst toastSelector = `.${toastString}`;\nconst toastDismissSelector = `[${dataBsDismiss}=\"${toastString}\"]`;\nconst showingClass = 'showing';\n/** @deprecated */\nconst hideClass = 'hide';\n\nconst toastDefaults = {\n  animation: true,\n  autohide: true,\n  delay: 5000,\n};\n\n/**\n * Static method which returns an existing `Toast` instance associated\n * to a target `Element`.\n *\n * @type {BSN.GetInstance<Toast>}\n */\nconst getToastInstance = (element) => getInstance(element, toastComponent);\n\n/**\n * A `Toast` initialization callback.\n * @type {BSN.InitCallback<Toast>}\n */\nconst toastInitCallback = (element) => new Toast(element);\n\n// TOAST CUSTOM EVENTS\n// ===================\nconst showToastEvent = OriginalEvent(`show.bs.${toastString}`);\nconst shownToastEvent = OriginalEvent(`shown.bs.${toastString}`);\nconst hideToastEvent = OriginalEvent(`hide.bs.${toastString}`);\nconst hiddenToastEvent = OriginalEvent(`hidden.bs.${toastString}`);\n\n// TOAST PRIVATE METHODS\n// =====================\n/**\n * Executes after the toast is shown to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToastComplete(self) {\n  const { element, options } = self;\n  removeClass(element, showingClass);\n  Timer.clear(element, showingClass);\n\n  dispatchEvent(element, shownToastEvent);\n  if (options.autohide) {\n    Timer.set(element, () => self.hide(), options.delay, toastString);\n  }\n}\n\n/**\n * Executes after the toast is hidden to the user.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToastComplete(self) {\n  const { element } = self;\n  removeClass(element, showingClass);\n  removeClass(element, showClass);\n  addClass(element, hideClass); // B/C\n  Timer.clear(element, toastString);\n  dispatchEvent(element, hiddenToastEvent);\n}\n\n/**\n * Executes before hiding the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction hideToast(self) {\n  const { element, options } = self;\n  addClass(element, showingClass);\n\n  if (options.animation) {\n    reflow(element);\n    emulateTransitionEnd(element, () => hideToastComplete(self));\n  } else {\n    hideToastComplete(self);\n  }\n}\n\n/**\n * Executes before showing the toast.\n * @param {Toast} self the `Toast` instance\n */\nfunction showToast(self) {\n  const { element, options } = self;\n  Timer.set(element, () => {\n    removeClass(element, hideClass); // B/C\n    reflow(element);\n    addClass(element, showClass);\n    addClass(element, showingClass);\n\n    if (options.animation) {\n      emulateTransitionEnd(element, () => showToastComplete(self));\n    } else {\n      showToastComplete(self);\n    }\n  }, 17, showingClass);\n}\n\n/**\n * Toggles on/off the `click` event listener.\n * @param {Toast} self the `Toast` instance\n * @param {boolean=} add when `true`, it will add the listener\n */\nfunction toggleToastHandlers(self, add) {\n  const action = add ? addListener : removeListener;\n  const { element, dismiss, options } = self;\n  if (dismiss) {\n    action(dismiss, mouseclickEvent, self.hide);\n  }\n  if (options.autohide) {\n    [focusinEvent, focusoutEvent, mouseenterEvent, mouseleaveEvent]\n      .forEach((e) => action(element, e, interactiveToastHandler));\n  }\n}\n\n// TOAST EVENT HANDLERS\n// ====================\n/**\n * Executes after the instance has been disposed.\n * @param {Toast} self the `Toast` instance\n */\nfunction completeDisposeToast(self) {\n  Timer.clear(self.element, toastString);\n  toggleToastHandlers(self);\n}\n\n/**\n * Executes when user interacts with the toast without closing it,\n * usually by hovering or focusing it.\n *\n * @this {HTMLElement | Element}\n * @param {MouseEvent} e the `Toast` instance\n */\nfunction interactiveToastHandler(e) {\n  const element = this;\n  const self = getToastInstance(element);\n  const { type, relatedTarget } = e;\n  // @ts-ignore\n  if (!self || (element === relatedTarget || element.contains(relatedTarget))) return;\n\n  if ([mouseenterEvent, focusinEvent].includes(type)) {\n    Timer.clear(element, toastString);\n  } else {\n    Timer.set(element, () => self.hide(), self.options.delay, toastString);\n  }\n}\n\n// TOAST DEFINITION\n// ================\n/** Creates a new `Toast` instance. */\nclass Toast extends BaseComponent {\n  /**\n   * @param {HTMLElement | Element | string} target the target `.toast` element\n   * @param {BSN.Options.Toast=} config the instance options\n   */\n  constructor(target, config) {\n    super(target, config);\n    // bind\n    const self = this;\n    const { element, options } = self;\n\n    // set fadeClass, the options.animation will override the markup\n    if (options.animation && !hasClass(element, fadeClass)) addClass(element, fadeClass);\n    else if (!options.animation && hasClass(element, fadeClass)) removeClass(element, fadeClass);\n    // dismiss button\n    /** @type {(HTMLElement | Element)?} */\n    self.dismiss = querySelector(toastDismissSelector, element);\n\n    // bind\n    self.show = self.show.bind(self);\n    self.hide = self.hide.bind(self);\n\n    // add event listener\n    toggleToastHandlers(self, true);\n  }\n\n  /* eslint-disable */\n  /**\n   * Returns component name string.\n   * @readonly @static\n   */  \n  get name() { return toastComponent; }\n  /**\n   * Returns component default options.\n   * @readonly @static\n   */  \n  get defaults() { return toastDefaults; }\n  /* eslint-enable */\n\n  // TOAST PUBLIC METHODS\n  // ====================\n  /** Shows the toast. */\n  show() {\n    const self = this;\n    const { element } = self;\n    if (element && !hasClass(element, showClass)) {\n      dispatchEvent(element, showToastEvent);\n      if (showToastEvent.defaultPrevented) return;\n\n      showToast(self);\n    }\n  }\n\n  /** Hides the toast. */\n  hide() {\n    const self = this;\n    const { element } = self;\n\n    if (element && hasClass(element, showClass)) {\n      dispatchEvent(element, hideToastEvent);\n      if (hideToastEvent.defaultPrevented) return;\n      hideToast(self);\n    }\n  }\n\n  /** Removes the `Toast` component from the target element. */\n  dispose() {\n    const self = this;\n    const { element } = self;\n\n    if (hasClass(element, showClass)) {\n      removeClass(element, showClass);\n    }\n\n    completeDisposeToast(self);\n\n    super.dispose();\n  }\n}\n\nObjectAssign(Toast, {\n  selector: toastSelector,\n  init: toastInitCallback,\n  getInstance: getToastInstance,\n});\n\n/**\n * Check if element matches a CSS selector.\n *\n * @param {HTMLElement | Element} target\n * @param {string} selector\n * @returns {boolean}\n */\nfunction matches(target, selector) {\n  return target.matches(selector);\n}\n\n/** @type {Record<string, any>} */\nconst componentsList = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n};\n\n/**\n * Initialize all matched `Element`s for one component.\n * @param {BSN.InitCallback<any>} callback\n * @param {NodeListOf<HTMLElement | Element> | (HTMLElement | Element)[]} collection\n */\nfunction initComponentDataAPI(callback, collection) {\n  [...collection].forEach((x) => callback(x));\n}\n\n/**\n * Remove one component from a target container element or all in the page.\n * @param {string} component the component name\n * @param {(Element | HTMLElement | Document)=} context parent `Element`\n */\nfunction removeComponentDataAPI(component, context) {\n  const compData = Data.getAllFor(component);\n\n  if (compData) {\n    [...compData].forEach((x) => {\n      const [element, instance] = x;\n      if (context && context.contains(element)) instance.dispose();\n    });\n  }\n}\n\n/**\n * Initialize all BSN components for a target container.\n * @param {(Element | HTMLElement | Document)=} context parent `Element`\n */\nfunction initCallback(context) {\n  const lookUp = context && parentNodes.some((x) => context instanceof x)\n    ? context : undefined;\n  const elemCollection = [...getElementsByTagName('*', lookUp)];\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    const { init, selector } = componentsList[comp];\n    initComponentDataAPI(init, elemCollection.filter((item) => matches(item, selector)));\n  });\n}\n\n/**\n * Remove all BSN components for a target container.\n * @param {(Element | HTMLElement | Document)=} context parent `Element`\n */\nfunction removeDataAPI(context) {\n  const lookUp = context && parentNodes.some((x) => context instanceof x)\n    ? context : undefined;\n\n  ObjectKeys(componentsList).forEach((comp) => {\n    removeComponentDataAPI(comp, lookUp);\n  });\n}\n\n// bulk initialize all components\nif (document.body) initCallback();\nelse {\n  addListener(document, 'DOMContentLoaded', () => initCallback(), { once: true });\n}\n\nconst BSN = {\n  Alert,\n  Button,\n  Carousel,\n  Collapse,\n  Dropdown,\n  Modal,\n  Offcanvas,\n  Popover,\n  ScrollSpy,\n  Tab,\n  Toast,\n  Tooltip,\n\n  initCallback,\n  removeDataAPI,\n  Version,\n  EventListener,\n};\n\nexport { BSN as default };\n","import BSN from 'bootstrap.native';\n\nconst modal = new BSN.Modal('#subscriptionModal');\nconsole.log(modal);\nmodal.show();\n\nconst refs = {\n  startBtn: document.querySelector('[data-start]'),\n  stopBtn: document.querySelector('[data-stop]'),\n};\nconsole.log(refs.startBtn);\nconsole.log(refs.stopBtn);\nfunction getRandomHexColor() {\n  return `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n}\n\n// const PROMPT_DELAY = 1000;\n// const MAX_PROMPT_ATTEMPTS = 3;\n\n// let promptCounter = 0;\n// console.log(promptCounter);\n\n// const naughtyInterval = setInterval(() => {\n//   if (promptCounter === MAX_PROMPT_ATTEMPTS) {\n//     console.log('остановили интервал');\n//     clearInterval(naughtyInterval);\n//     return;\n//   }\n\n//   console.log('Subscribe please - ' + Date.now());\n//   promptCounter += 1;\n//   console.log(promptCounter);\n// }, PROMPT_DELAY);\n"]}